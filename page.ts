// Copyright 2024 the Marveluzz authors. All rights reserved. MIT license.
import { CallbackRegistry } from "./callback-registery.ts"
import { WebSocketAdapter } from "./websocket-adapter.ts";
import { outputCommandInterface, Widgets } from "./widgets.ts"

/**
 * Class for managing the scope tree
 */
class TreeNode<T> {
  parent: TreeNode<T> | undefined;
  item: T;
  children: TreeNode<T>[];

  constructor(item: T, parent: TreeNode<T> | undefined = undefined) {
    this.item = item;
    this.children = [];
    this.parent = parent;
  }

  addChild(child: TreeNode<T>): void {
    this.children.push(child);

  }
  get(): T {
    return this.item;
  }


  findChild(item: T): TreeNode<T> | undefined {
    if (this.equals(item)) {
      return this;
    }
    for (const child of this.children) {
      if (child.equals(item)) {
        return child; // Return the matched child
      } else {
        const foundInDescendants = child.findChild(item); // Recursively search in descendants
        if (foundInDescendants) {
          return foundInDescendants; // Return the match found in descendants
        }
      }
    }
    return undefined; // Return undefined if no match is found and returned
  }

  equals(item: T): boolean {
    return item === this.item;
  }

  remove() {
    if (this.parent !== undefined) {
      // remove from Callback registery
      this.parent.removeChild(this.item);
    }
  }

  removeChild(item: T) { //}, callback: () => void) {
    this.children = this.children.filter(child => {
      if (child.equals(item)) {
        return false;
      } else {
        return true;
      }
    });
  }

  removeAllChildren(): void {
    for (const child of this.children) {
      child.removeAllChildren();
      child.remove();
    }
  }
}

// Scope management? Callbacks
const SCOPE_PREFIX: string = "pywebio-scope-";

/**
 * Manages the client side notably by sending commands, handling events and managing scope tree mirroring the DOM tree on client side.
 */
export class Page {
  private socket: WebSocketAdapter;
  private callbacks: CallbackRegistry;
  private scopeRoot: TreeNode<string>; // TODO ?
  private currentScope: TreeNode<string>;

  /**
   * Used internally, the initialized class will be provided to the App page callback.
   * @param socket
   * The opened websocket to communicate with the client side JS
   */
  constructor(socket: WebSocketAdapter) {
    this.scopeRoot = new TreeNode<string>("ROOT");
    this.currentScope = this.scopeRoot;
    this.socket = socket;
    this.callbacks = new CallbackRegistry();
    socket.addEventListener('message', (event: MessageEvent) => {
      //console.log(`Message from client: ${event.data}`);
      this.handleMessage(event);
    });
  }

  /**
   * 
   * @param command
   * A command for creating a widget generated by the Widgets module
   * @param callback
   * A callback to handle events related to the added Widget
   * A 
   * @returns 
   */
  add({ command, callback }: { command: outputCommandInterface, callback?: () => void }): void {
    //console.log(command);
    let scope: string;
    if (command.spec.scope === undefined) { // We manage scope here we ensure command.spec.scope exists
      scope = command.spec.scope = this.currentScope.get();
    } else {
      const matchedScope = this.scopeRoot.findChild(command.spec.scope);
      if (matchedScope === undefined) {
        return; // Just ignore if scope does not exist - In the future there might be 
      }
      scope = matchedScope.get();
    }

    if (callback) {
      const callback_id = this.addCallback(command.spec.scope, callback);
      command.spec.callback_id = callback_id;
    }

    // type scope specific handling
    const type = command.spec.type;
    if (type === "scope" && command.spec.dom_id !== undefined) { // pre-process scope command
      const find_scope = this.scopeRoot.findChild(command.spec.dom_id);
      if (find_scope !== undefined) {
        this.currentScope = find_scope; // TODO inconsitent in case scope exist but with a different context scope -> add check
        return // just update the current scope
      }
      const context_scope = this.scopeRoot.findChild(scope);
      this.currentScope = new TreeNode<string>(command.spec.dom_id)
      context_scope?.addChild(this.currentScope);
      command.spec.dom_id = Page.scope2dom(command.spec.dom_id);
    } else {
      if (type === "scope") {
        return;
      }
    }
    command.spec.scope = "#" + Page.scope2dom(scope);
    //console.log(command);
    this.socket.send(JSON.stringify(command));
  }

  /**
   * Find a scope in the scope tree and make it the active scope. Nothing happens if the scope does not exist.
   * @param name 
   * Name of the scope to be used.
   */
  useScope(name: string | undefined = undefined) {
    if (name === undefined) {
      this.currentScope = this.scopeRoot;
    } else {
      const find_scope = this.scopeRoot.findChild(name);
      if (find_scope === undefined) {
        return; // TODO nothing happens if the scope does not exist
      } else {
        this.currentScope = find_scope;
      }
    }
    this.add(Widgets.put_scope(this.currentScope.get(), undefined)); // Inconsistency?
  }

  /**
   * Find a scope and remove it from the scope tree including its children. Nothing happens if the scope does not exist. If the current active scope is removed the current scope will be reset to the root scope.
   * @param name 
   * Name of the scope.
   */
  removeScope(name: string) { // TODO, clear: boolean = false) {
    const find_scope = this.scopeRoot.findChild(name);
    if (find_scope === undefined) {
      return // TODO Error handling?
    }
    find_scope.remove();
    if (this.scopeRoot.findChild(this.currentScope.get()) === undefined) {
      // TODO bug remove doesn't reset scope
      this.currentScope = this.scopeRoot; // reset currentScope if currentScope has been removed
    }
    // TODO clean-up callback registery
    const command = Widgets.remove_scope("#" + Page.scope2dom(name));
    //console.log(command);
    this.socket.send(JSON.stringify(command));

  }


  /**
   * Register a callback to the scope tree. This way callback can be clean-up in case a scope gets deleted.
   * @param scope 
   * @param callback 
   * @returns 
   */
  private addCallback(scope: string, callback: () => void): number {
    return this.callbacks.register(scope, callback);
  }

  /**
   * Return the value for input widgets where the user can enter values
   * @param name
   * Name of the widget
   * @returns
   * The value assigned to the input
   */
  async getValue<T>(name: string): Promise<T> {
    const command = {
      "command": "pin_value",
      "task_id": "",
      "spec": {
        "name": name
      }
    };
    return new Promise((resolve, reject) => {
      const messageHandler = (event: MessageEvent) => {
        try {
          const data = JSON.parse(event.data);
          if (data.event === "js_yield") {
            this.socket.removeEventListener('message', messageHandler as (event: Event) => void);
            resolve(data.data.value);
          }
        } catch (error) {
          this.socket.removeEventListener('message', messageHandler as (event: Event) => void);
          reject(error);
        }
      };
      this.socket.addEventListener("message", messageHandler as (event: Event) => void);
      //console.log(command);
      this.socket.send(JSON.stringify(command));
    });
  }

  /**
   * Input widgets can be read-only and used as output. (Interactive widget might be the name for that type)
   * @param name
   * Name of the input widget
   * @param value
   * Value the widget will be set to.
   */
  setValue<T>(name: string, value: T) {
    const command = {
      command: "pin_update",
      task_id: "",
      spec: {
        name: name,
        attributes: {
          value: value
        }
      }
    };
    this.socket.send(JSON.stringify(command));
  }

  /**
   * Handles messages coming from the client side JS
   * @param event 
   */
  private handleMessage(event: MessageEvent): void {
    const data = JSON.parse(event.data);
    //console.log(data);

    if (data.event === "callback") {
      const callback_id = data.task_id
      if (typeof callback_id !== "number") {
        throw new TypeError("task_id/callback_id must be a number");
      }
      this.callbacks.trigger(callback_id);
    } else if (data.event === "js_yield") {
      // Empty
    }
  }

  /**
   * Set focus on a specific input widget.
   * @param name 
   * Name of the input widget.
   */
  setFocus(name: string) { // TODO what if the widget does not exist?
    const command = {
      command: "run_script",
      task_id: "",
      spec: {
        code: `document.querySelector('[id^="${name}-"]').focus();`, // a bit hacky but works
        eval: false
      }
    }
    this.socket.send(JSON.stringify(command));
  }

  /**
   * Waits for the page to be closed
   * @returns 
   */
  async wait_for_close(): Promise<CloseEvent> {
    // TODO what if the page is already closed?
    // TODO add a timer option though the user can do some polling or housekeeping in-between.
    return new Promise((resolve) => {
      let close_listener = (event: CloseEvent) => {
        this.socket.removeEventListener("close", close_listener as (event: Event) => void);
        resolve(event);

      }
      this.socket.addEventListener('close', close_listener as (event: Event) => void);
    });
  }
  private static scope2dom(scope: string): string {
    return SCOPE_PREFIX + scope;
  }

}



/*

TODO - Future way to implement scope handling

class ResourceContext {
  private resourceStack: string[] = [];

  push(resource: string) {
      this.resourceStack.push(resource);
      console.log(`Acquired resource: ${resource}`);
  }

  pop() {
      const resource = this.resourceStack.pop();
      if (resource) {
          console.log(`Released resource: ${resource}`);
      }
  }

  // Helper method to mimic "with" behavior
  use(resource: string, callback: () => void) {
      this.push(resource);
      try {
          callback();
      } finally {
          this.pop();
      }
  }
}

// Usage
const context = new ResourceContext();

context.use('Resource1', () => {
  console.log('Using Resource1');
  // Do something with Resource1

  // You could even nest resources
  context.use('Resource2', () => {
      console.log('Using Resource2');
      // Do something with Resource2
  });

  // Resource2 is released automatically here
});

// Resource1 is released automatically here
*/
