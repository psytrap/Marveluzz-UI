# SOME DESCRIPTIVE TITLE.
# Copyright (C) WangWeimin
# This file is distributed under the same license as the PyWebIO package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: PyWebIO 1.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-16 23:13+0800\n"
"PO-Revision-Date: 2021-12-02 21:46+0800\n"
"Last-Translator: WangWeimin <wang0.618@qq.com>\n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 3.0\n"

#: ../../guide.rst:2
msgid "User's guide"
msgstr ""

#: ../../guide.rst:4
msgid ""
"If you are familiar with web development, you may not be accustomed to the usage of PyWebIO described below, which is different from the "
"traditional web development pattern that backend implement api and frontend display content. In PyWebIO, you only need to write code in Python."
msgstr ""
"如果你接触过Web开发，你可能对接下来描述的PyWebIO的用法感到不太习惯，不同于传统Web开发的后端实现接口、前端进行展示交互的模式，在PyWebIO中，所有的逻辑"
"都通过编写Python代码实现。"

#: ../../guide.rst:8
msgid ""
"In fact, the way of writing PyWebIO applications is more like writing a console program, except that the terminal here becomes a browser. Using the "
"imperative API provided by PyWebIO, you can simply call ``put_text()``, ``put_image()``, ``put_table()`` and other functions to output text, "
"pictures, tables and other content to the browser, or you can call some functions such as ``input()``, ``select()``, ``file_upload()`` to display "
"different forms on the browser to get user input. In addition, PyWebIO also provides support for click events, layout, etc. PyWebIO aims to allow "
"you to use the least code to interact with the user and provide a good user experience as much as possible."
msgstr ""
"你可以按照编写控制台程序的逻辑编写PyWebIO应用，只不过这里的终端变成了浏览器。通过PyWebIO提供的命令式API，你可以简单地调用 ``put_text()`` 、 "
"``put_image()`` 、 ``put_table()`` 等函数输出文本、图片、表格等内容到浏览器，也可以调用 ``input()`` 、 ``select()`` 、 ``file_upload()`` 等函数在浏"
"览器上显示不同表单来接收用户的输入。此外PyWebIO中还提供了点击事件、布局等支持，让你可以使用最少的代码完成与用户的交互，并尽可能提供良好的用户体验。"

#: ../../guide.rst:15
msgid ""
"This user guide introduces you the most of the features of PyWebIO. There is a demo link at the top right of the example codes in this document, "
"where you can run the example code online and see what happens."
msgstr ""
"本篇使用指南从几个方面对PyWebIO的使用进行介绍，覆盖了PyWebIO的绝大部分特性。本文档中大部分示例代码的右上方都有一个Demo链接，点击后可以在线预览代码的"
"运行效果。"

#: ../../guide.rst:19
msgid "Input"
msgstr "输入"

#: ../../guide.rst:21
msgid "The input functions are defined in the :doc:`pywebio.input </input>` module and can be imported using ``from pywebio.input import *``."
msgstr "输入函数都定义在 :doc:`pywebio.input </input>` 模块中，可以使用 ``from pywebio.input import *`` 引入。"

#: ../../guide.rst:23
msgid ""
"When calling the input function, an input form  will be popped up on the browser. PyWebIO's input functions is blocking (same as Python's built-in "
"``input()`` function) and will not return until the form is successfully submitted."
msgstr ""
"调用输入函数会在浏览器上弹出一个输入表单来获取输入。PyWebIO的输入函数是阻塞式的（和Python内置的 `input` 一样），在表单被成功提交之前，输入函数不会返"
"回。"

#: ../../guide.rst:27
msgid "Basic input"
msgstr "基本输入"

#: ../../guide.rst:29
msgid "Here are some basic types of input."
msgstr "首先是一些基本类型的输入。"

#: ../../guide.rst:31
msgid "Text input:"
msgstr "文本输入:"

#: ../../guide.rst:33
#, python-format
msgid ""
"age = input(\"How old are you?\", type=NUMBER)\n"
"put_text('age = %r' % age)  # ..demo-only"
msgstr ""

#: ../../guide.rst:40
msgid ""
"After running the above code, the browser will pop up a text input field to get the input. After the user completes the input and submits the form, "
"the function returns the value entered by the user."
msgstr "这样一行代码的效果为：浏览器会弹出一个文本输入框来获取输入，在用户完成输入将表单提交后，函数返回用户输入的值。"

#: ../../guide.rst:43
msgid "Here are some other types of input functions:"
msgstr "下面是一些其他类型的输入函数:"

#: ../../guide.rst:45
#, python-format
msgid ""
"# Password input\n"
"password = input(\"Input password\", type=PASSWORD)\n"
"put_text('password = %r' % password)  # ..demo-only\n"
"## ----\n"
"\n"
"# Drop-down selection\n"
"gift = select('Which gift you want?', ['keyboard', 'ipad'])\n"
"put_text('gift = %r' % gift)  # ..demo-only\n"
"## ----\n"
"\n"
"# Checkbox\n"
"agree = checkbox(\"User Term\", options=['I agree to terms and conditions'])\n"
"put_text('agree = %r' % agree)  # ..demo-only\n"
"## ----\n"
"\n"
"# Single choice\n"
"answer = radio(\"Choose one\", options=['A', 'B', 'C', 'D'])\n"
"put_text('answer = %r' % answer)  # ..demo-only\n"
"## ----\n"
"\n"
"# Multi-line text input\n"
"text = textarea('Text Area', rows=3, placeholder='Some text')\n"
"put_text('text = %r' % text)  # ..demo-only\n"
"## ----\n"
"\n"
"# File Upload\n"
"img = file_upload(\"Select a image:\", accept=\"image/*\")\n"
"if img:    # ..demo-only\n"
"    put_image(img['content'], title=img['filename'])  # ..demo-only"
msgstr ""
"# 密码输入\n"
"password = input(\"Input password\", type=PASSWORD)\n"
"put_text('password = %r' % password)  # ..demo-only\n"
"## ——\n"
"\n"
"# 下拉选择框\n"
"gift = select('Which gift you want?', ['keyboard', 'ipad'])\n"
"put_text('gift = %r' % gift)  # ..demo-only\n"
"## ——\n"
"\n"
"# 勾选选项\n"
"agree = checkbox(\"用户协议\", options=['I agree to terms and conditions'])\n"
"put_text('agree = %r' % agree)  # ..demo-only\n"
"## ——\n"
"\n"
"# 单选选项\n"
"answer = radio(\"Choose one\", options=['A', 'B', 'C', 'D'])\n"
"put_text('answer = %r' % answer)  # ..demo-only\n"
"## ——\n"
"\n"
"# 多行文本输入\n"
"text = textarea('Text Area', rows=3, placeholder='Some text')\n"
"put_text('text = %r' % text)  # ..demo-only\n"
"## ——\n"
"\n"
"# 文件上传\n"
"img = file_upload(\"Select a image:\", accept=\"image/*\")\n"
"if img:    # ..demo-only\n"
"    put_image(img['content'], title=img['filename'])  # ..demo-only"

#: ../../guide.rst:81
msgid "Parameter of input functions"
msgstr "输入选项"

#: ../../guide.rst:83
msgid ""
"There are many parameters that can be passed to the input function(for complete parameters, please refer to the :doc:`function document </input>`):"
msgstr "输入函数可指定的参数非常丰富（全部参数及含义请见 :doc:`函数文档 </input>` ）:"

#: ../../guide.rst:86
msgid ""
"input('This is label', type=TEXT, placeholder='This is placeholder',\n"
"        help_text='This is help text', required=True)"
msgstr ""

#: ../../guide.rst:93 ../../guide.rst:129 ../../guide.rst:279 ../../guide.rst:586
msgid "The results of the above example are as follows:"
msgstr "以上代码将在浏览器上显示如下："

#: ../../guide.rst:97
msgid ""
"You can specify a validation function for the input by using ``validate`` parameter. The validation function should return ``None`` when the check "
"passes, otherwise an error message will be returned:"
msgstr "我们可以为输入指定校验函数，校验函数应在校验通过时返回None，否则返回错误消息:"

#: ../../guide.rst:100
#, python-format
msgid ""
"def check_age(p):  # return None when the check passes, otherwise return the error message\n"
"    if p < 10:\n"
"        return 'Too young!!'\n"
"    if p > 60:\n"
"        return 'Too old!!'\n"
"\n"
"age = input(\"How old are you?\", type=NUMBER, validate=check_age)\n"
"put_text('age = %r' % age)  # ..demo-only"
msgstr ""

#: ../../guide.rst:113
msgid "When the user input an illegal value, the input field is displayed as follows:"
msgstr "当用户输入了不合法的值时，页面上的显示如下:"

#: ../../guide.rst:117
msgid "You can use ``code`` parameter in :func:`pywebio.input.textarea()` to make a code editing textarea."
msgstr ":func:`pywebio.input.textarea()`  中可以使用 ``code`` 参数来开启代码风格的编辑区。"

#: ../../guide.rst:119
msgid ""
"code = textarea('Code Edit', code={\n"
"    'mode': \"python\",\n"
"    'theme': 'darcula',\n"
"}, value='import something\\n# Write your python code')\n"
"put_code(code, language='python')  # ..demo-only"
msgstr ""

#: ../../guide.rst:135
msgid "Input Group"
msgstr "输入组"

#: ../../guide.rst:137
msgid ""
"PyWebIO uses input group to get multiple inputs in a single form. `pywebio.input.input_group()` accepts a list of single input function call as "
"parameter, and returns a dictionary with the ``name`` of the single input as its key and the input data as its value:"
msgstr ""
"PyWebIO支持输入组, 返回结果为一个字典。`pywebio.input.input_group()` 接受单项输入组成的列表作为参数, 返回以单项输入中的 ``name`` 作为键、以输入数据"
"为值的字典:"

#: ../../guide.rst:142
msgid ""
"def check_age(p):  # ..demo-only\n"
"    if p < 10:                  # ..demo-only\n"
"        return 'Too young!!'    # ..demo-only\n"
"    if p > 60:                  # ..demo-only\n"
"        return 'Too old!!'      # ..demo-only\n"
"                                # ..demo-only\n"
"data = input_group(\"Basic info\",[\n"
"  input('Input your name', name='name'),\n"
"  input('Input your age', name='age', type=NUMBER, validate=check_age)\n"
"])\n"
"put_text(data['name'], data['age'])"
msgstr ""

#: ../../guide.rst:158
msgid "The input group also supports using ``validate`` parameter to set the validation function, which accepts the entire form data as parameter:"
msgstr "输入组中同样支持使用 ``validate`` 参数设置校验函数，其接受整个表单数据作为参数:"

#: ../../guide.rst:160
msgid ""
"def check_age(p):  # single input item validation  # ..demo-only\n"
"    if p < 10:                  # ..demo-only\n"
"        return 'Too young!!'    # ..demo-only\n"
"    if p > 60:                  # ..demo-only\n"
"        return 'Too old!!'      # ..demo-only\n"
"                                # ..demo-only\n"
"def check_form(data):  # return (input name, error msg) when validation fail\n"
"    if len(data['name']) > 6:\n"
"        return ('name', 'Name too long!')\n"
"    if data['age'] <= 0:\n"
"        return ('age', 'Age can not be negative!')\n"
"\n"
"data = input_group(\"Basic info\",[           # ..demo-only\n"
"   input('Input your name', name='name'),   # ..demo-only\n"
"   input('Input your age', name='age', type=NUMBER, validate=check_age)  # ..demo-only\n"
"], validate=check_form)              # ..demo-only\n"
"put_text(data['name'], data['age'])    # ..demo-only"
msgstr ""

#: ../../guide.rst:183
msgid ""
"PyWebIO determines whether the input function is in `input_group()` or is called alone according to whether the ``name`` parameter is passed. So "
"when calling an input function alone, **do not** set the ``name`` parameter; when calling the input function in `input_group()`, you **must** "
"provide the ``name`` parameter."
msgstr ""
"PyWebIO 根据是否在输入函数中传入 ``name`` 参数来判断输入函数是在 `input_group()` 中还是被单独调用。所以当单独调用一个输入函数时, **不要** 设置 "
"``name`` 参数；而在 `input_group()` 中调用输入函数时，需 **务必提供** ``name`` 参数。"

#: ../../guide.rst:188
msgid "Output"
msgstr "输出"

#: ../../guide.rst:190
msgid "The output functions are all defined in the :doc:`pywebio.output </output>` module and can be imported using ``from pywebio.output import *``."
msgstr "输出函数都定义在 :doc:`pywebio.output </output>` 模块中，可以使用 ``from pywebio.output import *`` 引入。"

#: ../../guide.rst:193
msgid ""
"When output functions is called, the content will be output to the browser in real time. The output functions can be called at any time during the "
"application lifetime."
msgstr "调用输出函数后，内容会实时输出到浏览器，在应用的生命周期内，可以在任意时刻调用输出函数。"

#: ../../guide.rst:197
msgid "Basic Output"
msgstr "基本输出"

#: ../../guide.rst:199
msgid "Using output functions, you can output a variety of content, such as text, tables, images and so on:"
msgstr "PyWebIO提供了一系列函数来输出文本、表格、图像等格式:"

#: ../../guide.rst:201
msgid ""
"# Text Output\n"
"put_text(\"Hello world!\")\n"
"## ----\n"
"\n"
"# Table Output\n"
"put_table([\n"
"    ['Commodity', 'Price'],\n"
"    ['Apple', '5.5'],\n"
"    ['Banana', '7'],\n"
"])\n"
"## ----\n"
"\n"
"# Image Output\n"
"put_image(open('/path/to/some/image.png', 'rb').read())  # local image # ..doc-only\n"
"put_image('http://example.com/some-image.png')  # internet image # ..doc-only\n"
"put_image('https://www.python.org/static/img/python-logo.png')  # ..demo-only\n"
"## ----\n"
"\n"
"# Markdown Output\n"
"put_markdown('~~Strikethrough~~')\n"
"## ----\n"
"\n"
"# File Output\n"
"put_file('hello_word.txt', b'hello word!')\n"
"## ----\n"
"\n"
"# Show a PopUp\n"
"popup('popup title', 'popup text content')\n"
"\n"
"# Show a notification message\n"
"toast('New message 🔔')"
msgstr ""

#: ../../guide.rst:238
msgid ""
"For all output functions provided by PyWebIO, please refer to the :doc:`pywebio.output </output>` module. In addition, PyWebIO also supports data "
"visualization with some third-party libraries, see :doc:`Third-party library ecology </libraries_support>`."
msgstr ""
"PyWebIO提供的全部输出函数见 :doc:`pywebio.output </output>` 模块。另外，PyWebIO还支持一些第三方库来进行数据可视化，参见 :doc:`第三方库生态 </"
"libraries_support>` 。"

#: ../../guide.rst:245
msgid ""
"If you use PyWebIO in interactive execution environment of Python shell, IPython or jupyter notebook, you need call `show()` method explicitly to "
"show output::"
msgstr "如果你在Python shell, IPython 或 jupyter notebook这种交互式执行环境中使用PyWebIO，你需要显式调用 `show()` 方法来显示输出::"

#: ../../guide.rst:248
msgid ""
">>> put_text(\"Hello world!\").show()\n"
">>> put_table([\n"
"...     ['A', 'B'],\n"
"...     [put_markdown(...), put_text('C')]\n"
"... ]).show()"
msgstr ""

#: ../../guide.rst:258
msgid "Combined Output"
msgstr "组合输出"

#: ../../guide.rst:260
msgid "The output functions whose name starts with ``put_`` can be combined with some output functions as part of the final output:"
msgstr "函数名以 ``put_`` 开始的输出函数，可以与一些输出函数组合使用，作为最终输出的一部分："

#: ../../guide.rst:262
msgid "You can pass ``put_xxx()`` calls to `put_table() <pywebio.output.put_table>` as cell content:"
msgstr "`put_table() <pywebio.output.put_table>` 支持以 ``put_xxx()`` 调用作为单元格内容:"

#: ../../guide.rst:264
msgid ""
"put_table([\n"
"    ['Type', 'Content'],\n"
"    ['html', put_html('X<sup>2</sup>')],\n"
"    ['text', '<hr/>'],  # equal to ['text', put_text('<hr/>')]\n"
"    ['buttons', put_buttons(['A', 'B'], onclick=...)],  # ..doc-only\n"
"    ['buttons', put_buttons(['A', 'B'], onclick=put_text)],  # ..demo-only\n"
"    ['markdown', put_markdown('`Awesome PyWebIO!`')],\n"
"    ['file', put_file('hello.text', b'hello world')],\n"
"    ['table', put_table([['A', 'B'], ['C', 'D']])]\n"
"])"
msgstr ""

#: ../../guide.rst:283
msgid "Similarly, you can pass ``put_xxx()`` calls to `popup() <pywebio.output.popup>` as the popup content:"
msgstr "类似地， `popup() <pywebio.output.popup>` 也可以将 ``put_xxx()`` 调用作为弹窗内容:"

#: ../../guide.rst:285
msgid ""
"popup('Popup title', [\n"
"    put_html('<h3>Popup Content</h3>'),\n"
"    'plain html: <br/>',  # Equivalent to: put_text('plain html: <br/>')\n"
"    put_table([['A', 'B'], ['C', 'D']]),\n"
"    put_button('close_popup()', onclick=close_popup)\n"
"])"
msgstr ""

#: ../../guide.rst:296
msgid "In addition, you can use `put_widget() <pywebio.output.put_widget>` to make your own output widgets that can accept ``put_xxx()`` calls."
msgstr "另外，你可以使用 `put_widget() <pywebio.output.put_widget>` 来创建可以接受 ``put_xxx()`` 的自定义输出控件。"

#: ../../guide.rst:298
msgid "For a full list of functions that accept ``put_xxx()`` calls as content, see :ref:`Output functions list <output_func_list>`"
msgstr "接受 ``put_xxx()`` 调用作为参数的完整输出函数清单请见 :ref:`输出函数列表 <output_func_list>`"

#: ../../guide.rst:300
msgid "**Context Manager**"
msgstr "**上下文管理器**"

#: ../../guide.rst:302
msgid "Some output functions that accept ``put_xxx()`` calls as content can be used as context manager:"
msgstr "一些接受 ``put_xxx()`` 调用作为参数的输出函数支持作为上下文管理器来使用："

#: ../../guide.rst:304
msgid ""
"with put_collapse('This is title'):\n"
"    for i in range(4):\n"
"        put_text(i)\n"
"\n"
"    put_table([\n"
"        ['Commodity', 'Price'],\n"
"        ['Apple', '5.5'],\n"
"        ['Banana', '7'],\n"
"    ])"
msgstr ""

#: ../../guide.rst:318
msgid "For a full list of functions that support context manager, see :ref:`Output functions list <output_func_list>`"
msgstr "支持上下文管理器的完整函数清单请见 :ref:`输出函数列表 <output_func_list>`"

#: ../../guide.rst:324
msgid "Click Callback"
msgstr "事件回调"

#: ../../guide.rst:326
msgid ""
"As we can see from the above, the interaction of PyWebIO has two parts: input and output. The input function of PyWebIO is blocking, a form will be "
"displayed on the user's web browser when calling input function, the input function will not return until the user submits the form. The output "
"function is used to output content to the browser in real time. The input and output behavior of PyWebIO is consistent with the console program. "
"That's why we say PyWebIO turning the browser into a \"rich text terminal\". So you can write PyWebIO applications in script programming way."
msgstr ""
"从上面可以看出，PyWebIO把交互分成了输入和输出两部分：输入函数为阻塞式调用，会在用户浏览器上显示一个表单，在用户提交表单之前输入函数将不会返回；输出"
"函数将内容实时输出至浏览器。这种交互方式和控制台程序是一致的，因此PyWebIO应用非常适合使用控制台程序的编写逻辑来进行开发。"

#: ../../guide.rst:332
msgid ""
"In addition, PyWebIO also supports event callbacks: PyWebIO allows you to output some buttons and bind callbacks to them. The provided callback "
"function will be executed when the button is clicked."
msgstr "此外，PyWebIO还支持事件回调：PyWebIO允许你输出一些控件并绑定回调函数，当控件被点击时相应的回调函数便会被执行。"

#: ../../guide.rst:335
msgid "This is an example:"
msgstr "下面是一个例子:"

#: ../../guide.rst:337
#, python-format
msgid ""
"from functools import partial\n"
"\n"
"def edit_row(choice, row):\n"
"    put_text(\"You click %s button ar row %s\" % (choice, row))\n"
"\n"
"put_table([\n"
"    ['Idx', 'Actions'],\n"
"    [1, put_buttons(['edit', 'delete'], onclick=partial(edit_row, row=1))],\n"
"    [2, put_buttons(['edit', 'delete'], onclick=partial(edit_row, row=2))],\n"
"    [3, put_buttons(['edit', 'delete'], onclick=partial(edit_row, row=3))],\n"
"])"
msgstr ""

#: ../../guide.rst:353
msgid ""
"The call to `put_table() <pywebio.output.put_table>` will not block. When user clicks a button, the corresponding callback function will be invoked:"
msgstr "`put_table() <pywebio.output.put_table>` 的调用不会阻塞。当用户点击了某行中的按钮时，PyWebIO会自动调用相应的回调函数:"

#: ../../guide.rst:358
msgid "Of course, PyWebIO also supports outputting individual button:"
msgstr "当然，PyWebIO还支持单独的按钮控件:"

#: ../../guide.rst:360
#, python-format
msgid ""
"def btn_click(btn_val):\n"
"    put_text(\"You click %s button\" % btn_val)\n"
"\n"
"put_buttons(['A', 'B', 'C'], onclick=btn_click)  # a group of buttons\n"
"\n"
"put_button(\"Click me\", onclick=lambda: toast(\"Clicked\"))  # single button"
msgstr ""

#: ../../guide.rst:371
msgid ""
"In fact, all output can be bound to click events, not just buttons. You can call ``onclick()`` method after the output function (function name like "
"``put_xxx()``) call:"
msgstr "事实上，不仅是按钮，所有的输出都可以绑定点击事件。你可以在输出函数之后调用 ``onclick()`` 方法来绑定点击事件:"

#: ../../guide.rst:374
msgid ""
"put_image('some-image.png').onclick(lambda: toast('You click an image'))  # ..doc-only\n"
"put_image('https://www.python.org/static/img/python-logo.png').onclick(lambda: toast('You click an image'))  # ..demo-only\n"
"\n"
"# set onclick in combined output\n"
"put_table([\n"
"    ['Commodity', 'Price'],\n"
"    ['Apple', put_text('5.5').onclick(lambda: toast('You click the text'))],\n"
"])"
msgstr ""

#: ../../guide.rst:387
msgid "The return value of ``onclick()`` method is the object itself so it can be used in combined output."
msgstr "``onclick()`` 方法的返回值为对象本身，所以可以继续用于组合输出中。"

#: ../../guide.rst:392
msgid "Output Scope"
msgstr "输出域Scope"

#: ../../guide.rst:394
msgid ""
"PyWebIO uses the scope model to give more control to the location of content output. The output scope is a container of output content. You can "
"create a scope in somewhere and append content to it."
msgstr "PyWebIO使用scope模型来控制内容输出的位置。scope为输出内容的容器，你可以创建一个scope并将内容输出到其中。"

#: ../../guide.rst:397
msgid ""
"Each output function (function name like ``put_xxx()``) will output its content to a scope, the default is \"current scope\". The \"current scope\" "
"is set by `use_scope() <pywebio.output.use_scope>`."
msgstr ""
"每个输出函数（函数名形如 `put_xxx()` ）都会将内容输出到一个Scope，默认为\"当前Scope\"，\"当前Scope\"由 `use_scope() <pywebio.output.use_scope>` 设"
"置。"

#: ../../guide.rst:402
msgid "**use_scope()**"
msgstr ""

#: ../../guide.rst:404
msgid "You can use `use_scope() <pywebio.output.use_scope>` to open and enter a new output scope, or enter an existing output scope:"
msgstr "可以使用 `use_scope() <pywebio.output.use_scope>` 开启并进入一个新的输出域，或进入一个已经存在的输出域:"

#: ../../guide.rst:406
msgid ""
"with use_scope('scope1'):  # open and enter a new output: 'scope1'\n"
"    put_text('text1 in scope1')  # output text to scope1\n"
"\n"
"put_text('text in parent scope of scope1')  # output text to ROOT scope\n"
"\n"
"with use_scope('scope1'):  # enter an existing scope: 'scope1'\n"
"    put_text('text2 in scope1')  # output text to scope1"
msgstr ""
"with use_scope('scope1'):  # 创建并进入scope 'scope1'\n"
"    put_text('text1 in scope1')  # 输出内容到 scope1\n"
"\n"
"put_text('text in parent scope of scope1')  # 输出内容到 ROOT scope\n"
"\n"
"with use_scope('scope1'):  # 进入之前创建的scope 'scope1'\n"
"    put_text('text2 in scope1')  # 输出内容到 scope1"

#: ../../guide.rst:418 ../../guide.rst:439
msgid "The results of the above code are as follows::"
msgstr "以上代码将会输出::"

#: ../../guide.rst:420
msgid ""
"text1 in scope1\n"
"text2 in scope1\n"
"text in parent scope of scope1"
msgstr ""

#: ../../guide.rst:424
msgid "You can use ``clear`` parameter in `use_scope() <pywebio.output.use_scope>` to clear the existing content before entering the scope:"
msgstr "`use_scope() <pywebio.output.use_scope>` 还可以使用 `clear` 参数将scope中原有的内容清空:"

#: ../../guide.rst:426
msgid ""
"with use_scope('scope2'):\n"
"    put_text('create scope2')\n"
"\n"
"put_text('text in parent scope of scope2')\n"
"## ----\n"
"\n"
"with use_scope('scope2', clear=True):  # enter the existing scope and clear the previous content\n"
"    put_text('text in scope2')"
msgstr ""
"with use_scope('scope2'):\n"
"    put_text('create scope2')\n"
"\n"
"put_text('text in parent scope of scope2')\n"
"## ——\n"
"\n"
"with use_scope('scope2', clear=True):  # 进入之前创建的scope2，并清空原有内容\n"
"    put_text('text in scope2')"

#: ../../guide.rst:441
msgid ""
"text in scope2\n"
"text in parent scope of scope2"
msgstr ""

#: ../../guide.rst:444
msgid "`use_scope() <pywebio.output.use_scope>` can also be used as decorator:"
msgstr "`use_scope() <pywebio.output.use_scope>` 还可以作为装饰器来使用:"

#: ../../guide.rst:446
msgid ""
"import time  # ..demo-only\n"
"from datetime import datetime\n"
"\n"
"@use_scope('time', clear=True)\n"
"def show_time():\n"
"    put_text(datetime.now())\n"
"\n"
"while 1:          # ..demo-only\n"
"   show_time()    # ..demo-only\n"
"   time.sleep(1)  # ..demo-only"
msgstr ""

#: ../../guide.rst:461
msgid ""
"When calling ``show_time()`` for the first time, a ``time`` scope will be created, and the current time will be output to it. And then every time "
"the ``show_time()`` is called, the new content will replace the previous content."
msgstr "第一次调用 ``show_time`` 时，将会创建 ``time`` 输出域并在其中输出当前时间，之后每次调用 ``show_time()`` ，输出域都会被新的内容覆盖。"

#: ../../guide.rst:464
msgid ""
"Scopes can be nested. At the beginning, PyWebIO applications have only one ``ROOT`` scope. You can create new scope in a scope. For example, the "
"following code will create 3 scopes:"
msgstr "Scope支持嵌套。会话开始时，PyWebIO应用只有一个 ``ROOT`` scope。你可以在一个scope中创建新的scope。比如，以下代码将会创建3个scope:"

#: ../../guide.rst:467
#, python-format
msgid ""
"with use_scope('A'):\n"
"    put_text('Text in scope A')\n"
"\n"
"    with use_scope('B'):\n"
"        put_text('Text in scope B')\n"
"\n"
"with use_scope('C'):\n"
"    put_text('Text in scope C')\n"
"\n"
"put_html(\"\"\"<style>                                          # ..demo-only\n"
"#pywebio-scope-A {border: 1px solid red;}                    # ..demo-only\n"
"#pywebio-scope-B {border: 1px solid blue;margin:2px}         # ..demo-only\n"
"#pywebio-scope-C {border: 1px solid green;margin-top:2px}    # ..demo-only\n"
"</style>\"\"\")                                                 # ..demo-only\n"
"put_text()                                                   # ..demo-only\n"
"put_buttons([('Put text to %s' % i, i) for i in ('A', 'B', 'C')], lambda s: put_text(s, scope=s))  # ..demo-only"
msgstr ""

#: ../../guide.rst:489
msgid "The above code will generate the following scope layout::"
msgstr "以上代码将会产生如下Scope布局::"

#: ../../guide.rst:491
msgid ""
"┌─ROOT────────────────────┐\n"
"│                         │\n"
"│ ┌─A───────────────────┐ │\n"
"│ │ Text in scope A     │ │\n"
"│ │ ┌─B───────────────┐ │ │\n"
"│ │ │ Text in scope B │ │ │\n"
"│ │ └─────────────────┘ │ │\n"
"│ └─────────────────────┘ │\n"
"│                         │\n"
"│ ┌─C───────────────────┐ │\n"
"│ │ Text in scope C     │ │\n"
"│ └─────────────────────┘ │\n"
"└─────────────────────────┘"
msgstr ""

#: ../../guide.rst:507
msgid "**put_scope()**"
msgstr ""

#: ../../guide.rst:509
msgid ""
"We already know that the scope is a container of output content. So can we use this container as a sub-item of a output (like, set a cell in table "
"as a container)? Yes, you can use `put_scope() <pywebio.output.put_scope>` to create a scope explicitly. The function name starts with ``put_``, "
"which means it can be pass to the functions that accept ``put_xxx()`` calls."
msgstr ""
"我们已经知道scope实际上是输出内容的容器，那么我们能否将scope作为输出的子元素呢（比如将scope作为表格的一个cell），答案是肯定的。你可以使用 "
"`put_scope() <pywebio.output.put_scope>` 来显式创建一个scope，而从它以 ``put_`` 开头的函数名可以看出，它也可以被传递到任何可以接受 ``put_xxx()`` 调"
"用的地方。"

#: ../../guide.rst:514
msgid ""
"put_table([\n"
"    ['Name', 'Hobbies'],\n"
"    ['Tom', put_scope('hobby', content=put_text('Coding'))]  # hobby is initialized to coding\n"
"])\n"
"\n"
"## ----\n"
"with use_scope('hobby', clear=True):\n"
"    put_text('Movie')  # hobby is reset to Movie\n"
"\n"
"## ----\n"
"# append Music, Drama to hobby\n"
"with use_scope('hobby'):\n"
"    put_text('Music')\n"
"    put_text('Drama')\n"
"\n"
"## ----\n"
"# insert the Coding into the top of the hobby\n"
"put_markdown('**Coding**', scope='hobby', position=0)"
msgstr ""

#: ../../guide.rst:538
msgid "It is not allowed to have two scopes with the same name in the application."
msgstr ""

#: ../../guide.rst:540
msgid "**Scope control**"
msgstr "**输出域控制函数**"

#: ../../guide.rst:542
msgid ""
"In addition to `use_scope() <pywebio.output.use_scope>` and `put_scope() <pywebio.output.put_scope>`, PyWebIO also provides the following scope "
"control functions:"
msgstr "除了 `use_scope() <pywebio.output.use_scope>` 和 `put_scope() <pywebio.output.put_scope>` , PyWebIO还提供了以下scope控制函数："

#: ../../guide.rst:545
msgid "`clear(scope) <pywebio.output.clear>` : Clear the contents of the scope"
msgstr "`clear(scope) <pywebio.output.clear>` : 清除scope的内容"

#: ../../guide.rst:546
msgid "`remove(scope) <pywebio.output.remove>` : Remove scope"
msgstr "`remove(scope) <pywebio.output.remove>` : 移除scope"

#: ../../guide.rst:547
msgid "`scroll_to(scope) <pywebio.output.scroll_to>` : Scroll the page to the scope"
msgstr "`scroll_to(scope) <pywebio.output.scroll_to>` : 将页面滚动到scope处"

#: ../../guide.rst:549
msgid ""
"Also, all output functions (function name like ``put_xxx()``) support a ``scope`` parameter to specify the destination scope to output, and support "
"a ``position`` parameter to specify the insert position in target scope. Refer :ref:`output module <scope_param>` for more information."
msgstr ""
"另外，所有的输出函数还支持使用 ``scope`` 参数来指定输出的目的scope，也可使用 ``position`` 参数来指定在目标scope中输出的位置。更多信息参见 :ref:"
"`output 模块 <scope_param>` 。"

#: ../../guide.rst:554
msgid "Layout"
msgstr "布局"

#: ../../guide.rst:556
msgid ""
"In general, using the output functions introduced above is enough to output what you want, but these outputs are arranged vertically. If you want "
"to create a more complex layout (such as displaying a code block on the left side of the page and an image on the right), you need to use layout "
"functions."
msgstr "通常，使用上述输出函数足以完成大部分输出，但是这些输出之间全都是竖直排列的。如果想创建更复杂的布局，需要使用布局函数。"

#: ../../guide.rst:560
msgid "The ``pywebio.output`` module provides 3 layout functions, and you can create complex layouts by combining them:"
msgstr "``pywebio.output`` 模块提供了3个布局函数，通过对他们进行组合可以完成各种复杂的布局:"

#: ../../guide.rst:562
msgid "`put_row() <pywebio.output.put_row>` : Use row layout to output content. The content is arranged horizontally"
msgstr "`put_row() <pywebio.output.put_row>` : 使用行布局输出内容. 内容在水平方向上排列"

#: ../../guide.rst:563
msgid "`put_column() <pywebio.output.put_column>` : Use column layout to output content. The content is arranged vertically"
msgstr "`put_column() <pywebio.output.put_column>` : 使用列布局输出内容. 内容在竖直方向上排列"

#: ../../guide.rst:564
msgid "`put_grid() <pywebio.output.put_grid>` : Output content using grid layout"
msgstr "`put_grid() <pywebio.output.put_grid>` : 使用网格布局输出内容"

#: ../../guide.rst:566
msgid "Here is an example by combining ``put_row()`` and ``put_column()``:"
msgstr "通过组合 ``put_row()`` 和 ``put_column()`` 可以实现灵活布局:"

#: ../../guide.rst:568
msgid ""
"put_row([\n"
"    put_column([\n"
"        put_code('A'),\n"
"        put_row([\n"
"            put_code('B1'), None,  # None represents the space between the output\n"
"            put_code('B2'), None,\n"
"            put_code('B3'),\n"
"        ]),\n"
"        put_code('C'),\n"
"    ]), None,\n"
"    put_code('D'), None,\n"
"    put_code('E')\n"
"])"
msgstr ""

#: ../../guide.rst:591
msgid "The layout function also supports customizing the size of each part::"
msgstr "布局函数还支持自定义各部分的尺寸::"

#: ../../guide.rst:593
#, python-format
msgid "put_row([put_image(...), put_image(...)], size='40% 60%')  # The ratio of the width of two images is 2:3"
msgstr "put_row([put_image(…), put_image(…)], size='40% 60%')  # 左右两图宽度比2:3"

#: ../../guide.rst:595
msgid "For more information, please refer to the :ref:`layout functions documentation <style_and_layout>`."
msgstr "更多布局函数的用法及代码示例请查阅 :ref:`布局函数文档 <style_and_layout>` ."

#: ../../guide.rst:600
msgid "Style"
msgstr "样式"

#: ../../guide.rst:602
msgid ""
"If you are familiar with `CSS <https://en.wikipedia.org/wiki/CSS>`_ styles, you can use the ``style()`` method of output return to set a custom "
"style for the output."
msgstr ""
"如果你熟悉 `CSS样式 <https://www.google.com/search?q=CSS%E6%A0%B7%E5%BC%8F>`_ ，你还可以在输出函数后调用 ``style()`` 方法给输出设定自定义样式。"

#: ../../guide.rst:605
msgid "You can set the CSS style for a single ``put_xxx()`` output:"
msgstr "可以给单个的 ``put_xxx()`` 输出设定CSS样式，也可以配合组合输出使用:"

#: ../../guide.rst:607
msgid ""
"put_text('hello').style('color: red; font-size: 20px')\n"
"\n"
"## ----\n"
"# in combined output\n"
"put_row([\n"
"    put_text('hello').style('color: red'),\n"
"    put_markdown('markdown')\n"
"]).style('margin-top: 20px')"
msgstr ""

#: ../../guide.rst:620
msgid "The return value of ``style()`` method is the object itself so it can be used in combined output."
msgstr "``style()`` 方法的返回值为对象本身，所以可以继续用于组合输出中。"

#: ../../guide.rst:625
msgid "Run application"
msgstr ""

#: ../../guide.rst:627
msgid ""
"In PyWebIO, there are two modes to run PyWebIO applications: running as a script and using `pywebio.start_server() <pywebio.platform.tornado."
"start_server>` or `pywebio.platform.path_deploy() <pywebio.platform.path_deploy>` to run as a web service."
msgstr ""
"在PyWebIO中，有两种方式用来运行PyWebIO应用：作为脚本运行和使用 `pywebio.start_server() <pywebio.platform.tornado.start_server>` 或 `pywebio."
"platform.path_deploy() <pywebio.platform.path_deploy>` 来作为Web服务运行。"

#: ../../guide.rst:632
msgid "Overview"
msgstr ""

#: ../../guide.rst:636 ../../guide.rst:701
msgid "**Server mode**"
msgstr "**Server模式**"

#: ../../guide.rst:638
msgid ""
"In server mode, PyWebIO will start a web server to continuously provide services. When the user accesses the service address, PyWebIO will open a "
"new session and run PyWebIO application in it."
msgstr "在Server模式下，PyWebIO会启动一个Web服务来持续性地提供服务。当用户访问服务地址时，PyWebIO会开启一个新会话并运行PyWebIO应用。"

#: ../../guide.rst:641
msgid "`start_server() <pywebio.platform.tornado.start_server>` is the most common way to start a web server to serve given PyWebIO applications::"
msgstr "将PyWebIO应用部署为web服务的最常用方式是使用 `start_server() <pywebio.platform.tornado.start_server>` ::"

#: ../../guide.rst:644
msgid ""
"from pywebio import *\n"
"\n"
"def main():  # PyWebIO application function\n"
"    name = input.input(\"what's your name\")\n"
"    output.put_text(\"hello\", name)\n"
"\n"
"start_server(main, port=8080, debug=True)"
msgstr ""

#: ../../guide.rst:652
msgid "Now head over to http://127.0.0.1:8080/, and you should see your hello greeting."
msgstr "现在，在 http://127.0.0.1:8080/ 页面就会看到欢迎页面了。"

#: ../../guide.rst:654
msgid "By using ``debug=True`` to enable debug mode, the server will automatically reload if code changes."
msgstr "使用 ``debug=True`` 来开启debug模式，这时server会在检测到代码发生更改后进行重启。"

#: ../../guide.rst:656
msgid ""
"The `start_server() <pywebio.platform.tornado.start_server>` provide a remote access support, when enabled (by passing `remote_access=True` to "
"`start_server()`), you will get a public, shareable address for the current application, others can access your application in their browser via "
"this address. Because the processing happens on your device (as long as your device stays on!), you don't have to worry about any dependencies. "
"Using remote access makes it easy to temporarily share the application with others."
msgstr ""
"`start_server() <pywebio.platform.tornado.start_server>` 提供了对远程访问的支持，当开启远程访问后（通过在 `start_server()` 中传入 "
"`remote_access=True` 开启 ），你将会得到一个用于访问当前应用的临时的公网访问地址，其他任何人都可以使用此地址访问你的应用。远程接入可以很方便地将应用"
"临时分享给其他人。"

#: ../../guide.rst:662
msgid ""
"Another way to deploy PyWebIO application as web service is using `path_deploy() <pywebio.platform.path_deploy>`. `path_deploy() <pywebio.platform."
"path_deploy>` is used to deploy the PyWebIO applications from a directory. Just define PyWebIO applications in python files under this directory, "
"and you can access them via the path in the URL. Refer to :ref:`platform module <dir_deploy>` for more information."
msgstr ""
"将PyWebIO应用部署为web服务的另一种方式是使用 `path_deploy() <pywebio.platform.path_deploy>` 。`path_deploy() <pywebio.platform.path_deploy>` 可以从"
"一个目录中部署PyWebIO应用，只需要在该目录下的python文件中定义PyWebIO应用，就可以通过URL中的路径来访问这些应用了。"

#: ../../guide.rst:669
msgid ""
"Note that in Server mode, all functions from ``pywebio.input``, ``pywebio.output`` and ``pywebio.session`` modules can only be called in the "
"context of PyWebIO application functions. For example, the following code is **not allowed**::"
msgstr ""
"注意，在Server模式下， ``pywebio.input`` 、 ``pywebio.output`` 和 ``pywebio.session`` 模块内的函数仅能在任务函数上下文中进行调用。比如如下调用是 **"
"不被允许的** ::"

#: ../../guide.rst:672
msgid ""
"import pywebio\n"
"from pywebio.input import input\n"
"\n"
"port = input('Input port number:')   # ❌ error\n"
"pywebio.start_server(my_task_func, port=int(port))"
msgstr ""

#: ../../guide.rst:679 ../../guide.rst:696
msgid "**Script mode**"
msgstr "**Script模式**"

#: ../../guide.rst:681
msgid "If you never call ``start_server()`` or ``path_deploy()`` in your code, then you are running PyWebIO application as script mode."
msgstr "如果你在代码中没有调用 ``start_server()`` 或 ``path_deploy()`` 函数，那么你就是以脚本模式在运行PyWebIO应用。"

#: ../../guide.rst:683
msgid ""
"In script mode, a web browser page will be open automatically when running to the first call to PyWebIO interactive functions, and all subsequent "
"PyWebIO interactions will take place on this page. When the script exit, the page will be inactive."
msgstr ""
"在脚本模式中，当首次运行到对PyWebIO交互函数的调用时，会自动打开浏览器的一个页面，后续的PyWebIO交互都会在这个页面上进行。当脚本运行结束，这个页面也将"
"不再有效。"

#: ../../guide.rst:686
msgid ""
"If the user closes the browser before the script exiting, then subsequent calls to PyWebIO's interactive functions will cause a `SessionException "
"<pywebio.exceptions.SessionException>` exception."
msgstr ""
"如果用户在脚本结束运行之前关闭了浏览器，那么之后会话内对于PyWebIO交互函数的调用将会引发一个 `SessionException <pywebio.exceptions."
"SessionException>` 异常。"

#: ../../guide.rst:692
msgid "Concurrent"
msgstr "并发"

#: ../../guide.rst:694
msgid "PyWebIO can be used in a multi-threading environment."
msgstr "PyWebIO 支持在多线程环境中使用。"

#: ../../guide.rst:698
msgid ""
"In script mode, you can freely start new thread and call PyWebIO interactive functions in it. When all `non-daemonic <https://docs.python.org/3/"
"library/threading.html#thread-objects>`_ threads finish running, the script exits."
msgstr ""
"在 Script模式下，你可以自由地启动线程，并在其中调用PyWebIO的交互函数。当所有非 `Daemon线程 <https://docs.python.org/3/library/threading.html#thread-"
"objects>`_ 运行结束后，脚本退出。"

#: ../../guide.rst:703
msgid ""
"In server mode, if you need to use PyWebIO interactive functions in new thread, you need to use `pywebio.session.register_thread(thread) <pywebio."
"session.register_thread>` to register the new thread (so that PyWebIO can know which session the thread belongs to). If the PyWebIO interactive "
"function is not used in the new thread, no registration is required. Threads that are not registered with `register_thread(thread) <pywebio.session."
"register_thread>` calling PyWebIO's interactive functions will cause `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>`."
msgstr ""
"Server模式下，如果需要在新创建的线程中使用PyWebIO的交互函数，需要手动调用 `register_thread(thread) <pywebio.session.register_thread>` 对新进程进行注"
"册（这样PyWebIO才能知道新创建的线程属于哪个会话）。如果新创建的线程中没有使用到PyWebIO的交互函数，则无需注册。没有使用 `register_thread(thread) "
"<pywebio.session.register_thread>` 注册的线程不受会话管理，其调用PyWebIO的交互函数将会产生 `SessionNotFoundException <pywebio.exceptions."
"SessionNotFoundException>` 异常。"

#: ../../guide.rst:710
msgid "Example of using multi-threading in Server mode::"
msgstr "Server模式下多线程的使用示例::"

#: ../../guide.rst:712
msgid ""
"def show_time():\n"
"    while True:\n"
"        with use_scope(name='time', clear=True):\n"
"            put_text(datetime.datetime.now())\n"
"            time.sleep(1)\n"
"\n"
"def app():\n"
"    t = threading.Thread(target=show_time)\n"
"    register_thread(t)\n"
"    put_markdown('## Clock')\n"
"    t.start()  # run `show_time()` in background\n"
"\n"
"    # ❌ this thread will cause `SessionNotFoundException`\n"
"    threading.Thread(target=show_time).start()\n"
"\n"
"    put_text('Background task started.')\n"
"\n"
"\n"
"start_server(app, port=8080, debug=True)"
msgstr ""

#: ../../guide.rst:736
msgid "Close of session"
msgstr "会话的结束"

#: ../../guide.rst:738
msgid ""
"When user close the browser page, the session will be closed. After the browser page is closed, PyWebIO input function calls that have not yet "
"returned in the current session will cause `SessionClosedException <pywebio.exceptions.SessionClosedException>`, and subsequent calls to PyWebIO "
"interactive functions will cause `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` or `SessionClosedException <pywebio."
"exceptions.SessionClosedException>`."
msgstr ""
"当用户关闭浏览器页面时，与之相应的会话也将被关闭。会话关闭后，应用中未返回的PyWebIO输入函数的调用将会抛出 `SessionClosedException <pywebio."
"exceptions.SessionClosedException>` 异常，后续对PyWebIO交互函数的调用将会引发 `SessionNotFoundException <pywebio.exceptions."
"SessionNotFoundException>` 或 `SessionClosedException <pywebio.exceptions.SessionClosedException>` 异常。"

#: ../../guide.rst:743
msgid "In most cases, you don't need to catch those exceptions, because let those exceptions to abort the running is the right way to exit."
msgstr "大部分情况下，你不需要捕获这些异常，让这些异常来终止代码的执行通常是比较合适的。"

#: ../../guide.rst:745
msgid ""
"You can use `pywebio.session.defer_call(func) <pywebio.session.defer_call>` to set the function to be called when the session closes. "
"`defer_call(func) <pywebio.session.defer_call>` can be used for resource cleaning. You can call `defer_call(func) <pywebio.session.defer_call>` "
"multiple times in the session, and the set functions will be executed sequentially after the session closes."
msgstr ""
"可以使用 `pywebio.session.defer_call(func) <pywebio.session.defer_call>` 来设置会话结束时需要调用的函数。无论是因为用户主动关闭页面还是任务结束使得"
"会话关闭，设置的函数都会被执行。`defer_call(func) <pywebio.session.defer_call>` 可以用于资源清理等工作。在会话中可以多次调用 `defer_call() <pywebio."
"session.defer_call>` ,会话结束后将会顺序执行设置的函数。"

#: ../../guide.rst:751
msgid "More about PyWebIO"
msgstr ""

#: ../../guide.rst:752
msgid ""
"By now, you already get the most important features of PyWebIO and can start to write awesome PyWebIO applications. However, there are some other "
"useful features we don't cover in the above. Here we just make a briefly explain about them. When you need them in your application, you can refer "
"to their document."
msgstr ""
"目前为止，你已经了解了PyWebIO中最重要的特性，并且可以开始编写PyWebIO应用了。然而，有些功能前面我们并没有覆盖到，这里提供了对剩余特性的一些简短介绍，"
"如果你在应用编写过程中需要用到这里的某个特性，你可以查阅对应的详细文档。"

#: ../../guide.rst:756
msgid "Also, :doc:`here </cookbook>` is a cookbook where you can find some useful code snippets for your PyWebIO application."
msgstr "另外，你可以在 :doc:`cookbook </cookbook>` 页面找到一些对于编写PyWebIO应用很有帮助的代码片段。"

#: ../../guide.rst:759
msgid "``session`` module"
msgstr "``session`` 模块"

#: ../../guide.rst:760
msgid "The :doc:`pywebio.session </session>` module give you more control to session."
msgstr ":doc:`pywebio.session </session>` 模块提供了对会话的更多控制 。"

#: ../../guide.rst:762
msgid "Use `set_env() <pywebio.session.set_env>` to configure the title, page appearance, input panel and so on for current session."
msgstr "使用 `set_env() <pywebio.session.set_env>` 来为当前会话设置标题、页面外观、输入栏等内容。"

#: ../../guide.rst:764
msgid ""
"The `info <pywebio.session.info>` object provides a lot information about the current session, such as the user IP address, user language and user "
"browser information."
msgstr "`info <pywebio.session.info>` 对象提供了关于当前绘画的很多信息，比如用户IP地址、用户语言、用户浏览器信息等。"

#: ../../guide.rst:767
msgid "`local <pywebio.session.local>` is a session-local storage, it used to save data whose values are session specific."
msgstr "`local <pywebio.session.local>` 是一个session-local的存储对象, 用于存储会话独立的数据。"

#: ../../guide.rst:769
msgid ""
"`run_js() <pywebio.session.run_js>` let you execute JavaScript code in user's browser, and `eval_js() <pywebio.session.eval_js>` let you execute "
"JavaScript expression and get the value of it."
msgstr ""
"`run_js() <pywebio.session.run_js>` 让你在用户浏览器中执行JavaScript代码, `eval_js() <pywebio.session.eval_js>` 让你执行并获取JavaScript表达式的值。"

#: ../../guide.rst:773
msgid "``pin`` module"
msgstr "``pin`` 模块"

#: ../../guide.rst:774
msgid ""
"As you already know, the input function of PyWebIO is blocking and the input form will be destroyed after successful submission. In some cases, you "
"may want to make the input form not disappear after submission, and can continue to receive input. So PyWebIO provides the :doc:`pywebio.pin </"
"pin>` module to achieve persistent input by pinning input widgets to the page."
msgstr ""
"你已经知道，PyWebIO的输入函数是阻塞式的，并且输入表单会在成功提交后消失。在某些时候，你可能想要输入表单一直显示并可以持续性接收用户输入，这时你可以"
"使用 :doc:`pywebio.pin </pin>` 模块。"

#: ../../guide.rst:779
msgid "``platform`` module"
msgstr "``platform`` 模块"

#: ../../guide.rst:781
msgid "The :doc:`pywebio.platform </platform>` module provides support for deploying PyWebIO applications in different ways."
msgstr ":doc:`pywebio.platform </platform>` 模块提供了将PyWebIO应用以多种方式部署的支持。"

#: ../../guide.rst:783
msgid ""
"There are two protocols (WebSocket and HTTP) can be used in server to communicates with the browser. The WebSocket is used by default. If you want "
"to use HTTP protocol, you can choose other ``start_server()`` functions in this module."
msgstr ""
"PyWebIO的服务端与浏览器可以通过两种协议(WebSocket 和 HTTP 协议)进行通信，默认使用WebSocket协议，如果你想使用HTTP协议，你可以选择本模块中的其他 "
"``start_server()`` 函数。"

#: ../../guide.rst:786
msgid ""
"You might want to set some web page related configuration (such as SEO information, js and css injection) for your PyWebIO application, `pywebio."
"config() <pywebio.config>` can be helpful."
msgstr "如果要为PyWebIO应用设置一些网页相关的配置，可以尝试使用 `pywebio.config() <pywebio.config>` 。"

#: ../../guide.rst:790
msgid "Advanced features"
msgstr "高级特性"

#: ../../guide.rst:792
msgid ""
"The PyWebIO application can be integrated into an existing Python web project, the PyWebIO application and the web project share a web framework. "
"Refer to :ref:`Advanced Topic: Integration with Web Framework <integration_web_framework>` for more information."
msgstr ""
"可以将PyWebIO应用整合到现存的Python Web项目中，PyWebIO应用和web项目使用一个web框架。详细信息参见 :ref:`Advanced Topic: Integration with Web "
"Framework <integration_web_framework>` 。"

#: ../../guide.rst:796
msgid ""
"PyWebIO also provides support for coroutine-based sessions. Refer to :ref:`Advanced Topic: Coroutine-based session <coroutine_based_session>` for "
"more information."
msgstr "PyWebIO还支持基于协程的会话。具体参见 :ref:`Advanced Topic: Coroutine-based session <coroutine_based_session>` 。"

#: ../../guide.rst:799
msgid ""
"If you try to bundles your PyWebIO application into a stand-alone executable file, to make users can run the application without installing a "
"Python interpreter or any modules, you might want to refer to :ref:`Libraries support: Build stand-alone App <stand_alone_app>`"
msgstr ""
"如果你想要将PyWebIO应用打包到一个单独的可执行文件里面，从而使用户可以在没有安装python解释器的情况下运行应用，你可以参考 :ref:`Build stand-alone App "
"<stand_alone_app>`"

#: ../../guide.rst:802
msgid ""
"If you want to make some data visualization in your PyWebIO application, you can't miss :ref:`Libraries support: Data visualization <visualization>`"
msgstr "如果你想在PyWebIO应用中进行一些数据可视化，可以参考 :ref:`Data visualization <visualization>`"

#: ../../guide.rst:805
msgid "Last but not least"
msgstr ""

#: ../../guide.rst:807
msgid "This is basically all features of PyWebIO, you can continue to read the rest of the documents, or start writing your PyWebIO applications now."
msgstr "以上基本就是PyWebIO的全部功能了，你可以继续阅读接下来的文档，或者立即开始PyWebIO应用的编写了。"

#: ../../guide.rst:809
msgid ""
"Finally, please allow me to provide one more suggestion. When you encounter a design problem when using PyWebIO, you can ask yourself a question: "
"What would I do if it is in a terminal program? If you already have the answer, it can be done in the same way with PyWebIO. If the problem "
"persists or the solution is not good enough, you can consider the :ref:`callback mechanism <callback>` or  :doc:`pin <./pin>` module."
msgstr ""
"最后再提供一条建议，当你在使用PyWebIO遇到设计上的问题时，可以问一下自己：如果在是在终端程序中我会怎么做？如果你已经有答案了，那么在PyWebIO中一样可以"
"使用这样的方式完成。如果问题依然存在或者觉得解决方案不够好，你可以考虑使用 :ref:`回调机制 <callback>` 或 :doc:`pin <./pin>` 模块。"

#: ../../guide.rst:814
msgid "OK, Have fun with PyWebIO!"
msgstr ""

#~ msgid ""
#~ "In the :ref:`Hello, world <hello_word>` section, we already know that PyWebIO supports two modes: running as a script and using `start_server() "
#~ "<pywebio.platform.tornado.start_server>` to run as a web service."
#~ msgstr ""
#~ "在 :ref:`Hello, world <hello_word>` 一节中，已经知道，PyWebIO支持在普通的脚本中调用和使用 `start_server() <pywebio.platform.tornado."
#~ "start_server>` 启动一个Web服务两种模式。"

#~ msgid ""
#~ "Other output functions that accept ``put_xxx()`` calls as parameters are `put_collapse() <pywebio.output.put_collapse>`, `put_scrollable() "
#~ "<pywebio.output.put_scrollable>`, `put_row() <pywebio.output.put_row>`, etc. In addition, you can use `put_widget() <pywebio.output.put_widget>` "
#~ "to make your own output widgets that can accept ``put_xxx()`` calls. For more information, please refer to corresponding function documentation."
#~ msgstr ""
#~ "其他接受 ``put_xxx()`` 调用作为参数的输出函数还有 `put_collapse() <pywebio.output.put_collapse>` 、 `put_scrollable() <pywebio.output."
#~ "put_scrollable>` 、`put_row() <pywebio.output.put_row>` 等，此外，还可以通过 `put_widget() <pywebio.output.put_widget>` 自定义可接收 "
#~ "``put_xxx()`` 调用的输出组件，具体用法请参考函数文档。"

#~ msgid ""
#~ "In general, using the various output functions introduced above is enough to output what you want, but these outputs are arranged vertically. If "
#~ "you want to make a more complex layout (such as displaying a code block on the left side of the page and an image on the right), you need to use "
#~ "layout functions."
#~ msgstr ""
#~ "一般情况下，使用上文介绍的各种输出函数足以完成各种内容的展示，但直接调用输出函数产生的输出之间都是竖直排列的，如果想实现更复杂的布局（比如在页面"
#~ "左侧显示一个代码块，在右侧显示一个图像），就需要借助布局函数。"

#~ msgid "Need to add a ``RequestHandler`` to Tornado application::"
#~ msgstr "需要在Tornado应用中引入一个 ``RequestHandler`` ::"

#~ msgid "One route need to be added to communicate with the browser through HTTP::"
#~ msgstr "需要添加一个PyWebIO相关的路由，用来和浏览器进行Http通讯::"

#~ msgid "Need to add a route in ``urls.py``::"
#~ msgstr "在django的路由配置文件 ``urls.py`` 中加入PyWebIO相关的路由即可::"

#~ msgid "One route need to be added to communicate with the browser through WebSocket::"
#~ msgstr "需要添加一个PyWebIO相关的路由，用来和浏览器进行WebSocket通讯::"

#~ msgid ""
#~ "See also: `FastAPI doc <https://www.starlette.io/routing/#submounting-routes>`_ , `Starlette doc <https://fastapi.tiangolo.com/advanced/sub-"
#~ "applications/>`_"
#~ msgstr ""
#~ "参见: `FastAPI doc <https://www.starlette.io/routing/#submounting-routes>`_ , `Starlette doc <https://fastapi.tiangolo.com/advanced/sub-"
#~ "applications/>`_"

#~ msgid ""
#~ "`style() <pywebio.output.style>` also accepts a list of output calls, `style() <pywebio.output.style>` will set the CSS style for each item of "
#~ "the list:"
#~ msgstr "``style()`` 也接受列表作为输入，``style()`` 会为列表的每一项都设置CSS样式，返回值可以直接输出，可用于任何接受 ``put_xxx()`` 列表的地方:"

#~ msgid "Use `pywebio.platform.tornado.webio_handler()` to get the ``RequestHandler`` class for running PyWebIO applications in Tornado::"
#~ msgstr "使用 `pywebio.platform.tornado.webio_handler()` 来获得在Tornado中运行PyWebIO应用的 ``RequestHandler`` 类::"

#~ msgid ""
#~ "In above code, we use `webio_handler(task_func) <pywebio.platform.tornado.webio_handler>` to get the Tornado `WebSocketHandler <https://www."
#~ "tornadoweb.org/en/stable/websocket.html#tornado.websocket.WebSocketHandler>`_  that communicates with the browser, and bind it to the ``/tool`` "
#~ "path. After starting the Tornado server, you can visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "以上代码调用 `webio_handler(task_func) <pywebio.platform.tornado.webio_handler>` 来获得PyWebIO和浏览器进行通讯的Tornado `WebSocketHandler "
#~ "<https://www.tornadoweb.org/en/stable/websocket.html#tornado.websocket.WebSocketHandler>`_ ，并将其绑定在 ``/tool`` 路由下。启动Tornado服务器后，"
#~ "访问 ``http://localhost/tool`` 即可打开PyWebIO应用。"

#~ msgid ""
#~ "In above code, we use `webio_view(task_func) <pywebio.platform.flask.webio_view>` to get the Flask view of the PyWebIO application, and bind it "
#~ "to ``/tool`` path. After starting the Flask application, visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "以上代码使用 `webio_view(task_func) <pywebio.platform.flask.webio_view>` 来获得运行PyWebIO应用的Flask视图 ，并调用 `Flask.add_url_rule <https://"
#~ "flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.add_url_rule>`_ 将其绑定在 ``/tool`` 路径下。启动Flask应用后，访问 ``http://localhost/tool`` "
#~ "即可打开PyWebIO应用。"

#~ msgid ""
#~ "The `start_server() <pywebio.platform.tornado.start_server>` provide a remote access support, when enabled (by passing `remote_access=True` to "
#~ "`start_server()`), you can get a temporary public network access address for the current application, others can access your application via "
#~ "this address. Using remote access makes it easy to temporarily share the application with others. This service is powered by `localhost.run "
#~ "<https://localhost.run>`_."
#~ msgstr ""
#~ "`start_server() <pywebio.platform.tornado.start_server>` 提供了远程访问的支持，当开启远程访问后（通过在 `start_server()` 中传入 "
#~ "`remote_access=True` 开启 ），你将会得到一个用于访问当前应用的临时的公网访问地址，其他人任何都可以使用此地址访问你的应用。远程接入可以很方便地将"
#~ "应用临时分享给其他人。当前远程接入功能由 `localhost.run <https://localhost.run>`_ 提供。"

#~ msgid ""
#~ "After the PyWebIO session (see :ref:`Server and script mode <server_and_script_mode>` for more information about session) closed, the event "
#~ "callback will not work. You can call the :func:`pywebio.session.hold()` function at the end of the task function to hold the session, so that "
#~ "the event callback will always be available before the browser page is closed by user."
#~ msgstr ""
#~ "在PyWebIO会话(关于会话的概念见下文 :ref:`Server与script模式 <server_and_script_mode>` )结束后，事件回调也将不起作用，你可以在任务函数末尾处使用 :"
#~ "func:`pywebio.session.hold()` 函数来将会话保持，这样在用户关闭浏览器页面前，事件回调将一直可用。"

#~ msgid ""
#~ "PyWebIO uses the scope model to give more control to the location of content output. The output area of PyWebIO can be divided into different "
#~ "output domains. The output domain is called Scope in PyWebIO."
#~ msgstr "PyWebIO使用Scope模型来对内容输出的位置进行灵活地控制，PyWebIO的内容输出区可以划分出不同的输出域，PyWebIO将输出域称作 `Scope` 。"

#~ msgid ""
#~ "The output domain is a container of output content, and each output domain is arranged vertically, and the output domains can also be nested."
#~ msgstr "输出域为输出内容的容器，各个输出域之间上下排列，输出域也可以进行嵌套。"

#~ msgid "**Scope related parameters of output function**"
#~ msgstr "**输出函数的scope相关参数**"

#~ msgid ""
#~ "The output function (function name like ``put_xxx()``) will output the content to the \"current scope\" by default, and the \"current scope\" of "
#~ "the runtime context can be set by ``use_scope()``."
#~ msgstr "输出函数（函数名形如 ``put_xxx()`` ）在默认情况下，会将内容输出到\"当前Scope\"，可以通过 ``use_scope()`` 设置运行时上下文的\"当前Scope\"。"

#~ msgid "In addition, you can use the ``scope`` parameter of the output function to specify the destination scope to output:"
#~ msgstr "此外，也可以通过输出函数的 ``scope`` 参数指定输出的目的Scope:"

#~ msgid ""
#~ "In addition to directly specifying the target scope name, the ``scope`` parameter can also accept an integer to determine the scope by indexing "
#~ "the scope stack: 0 means the top level scope(the ROOT Scope), -1 means the current scope, -2 means the scope used before entering the current "
#~ "scope, ..."
#~ msgstr ""
#~ "``scope`` 参数除了直接指定目标Scope名，还可以使用一个整形通过索引Scope栈来确定Scope：0表示最顶层也就是ROOT Scope，-1表示当前Scope，-2表示进入当前"
#~ "Scope前所使用的Scope，……"

#~ msgid ""
#~ "By default, the content output to the same scope will be arranged from top to bottom according to the calling order of the output function. The "
#~ "output content can be inserted into other positions of the target scope by using the ``position`` parameter of the output function."
#~ msgstr ""
#~ "默认条件下，在同一Scope中的输出内容，会根据输出函数的调用顺序从上往下排列，最后调用的输出函数会输出内容到目标Scope的底部。通过输出函数的 "
#~ "``position`` 参数可以将输出内容插入到目标Scope的其他位置。"

#~ msgid ""
#~ "Each output item in a scope has an index, the first item's index is 0, and the next item's index is incremented by one. You can also use a "
#~ "negative number to index the items in the scope, -1 means the last item, -2 means the item before the last..."
#~ msgstr ""
#~ "一个Scope中各次输出的元素具有像数组一样的索引，最前面的编号为0，以此往后递增加一；同样可以使用负数对Scope中的元素进行索引，-1表示最后面的元素，-2"
#~ "表示次后面的元素……"

#~ msgid ""
#~ "The ``position`` parameter of output functions accepts an integer. When ``position>=0``, it means to insert content before the item whose index "
#~ "equal ``position``; when ``position<0``, it means to insert content after the item whose index equal ``position``:"
#~ msgstr ""
#~ "``position`` 参数类型为整形， ``position>=0`` 时表示输出内容到目标Scope的第position号元素的前面； ``position<0`` 时表示输出内容到目标Scope第"
#~ "position号元素之后:"

#~ msgid "Page environment settings"
#~ msgstr "页面环境设置"

#~ msgid "**Page Title**"
#~ msgstr "**页面标题**"

#~ msgid "You can call `set_env(title=...) <pywebio.session.set_env>` to set the page title。"
#~ msgstr "调用 `set_env(title=…) <pywebio.session.set_env>` 可以设置页面标题。"

#~ msgid "**Auto Scroll**"
#~ msgstr "**自动滚动**"

#~ msgid ""
#~ "When performing some continuous output (such as log output), you may want to scroll the page to the bottom automatically when there is new "
#~ "output. You can call `set_env(auto_scroll_bottom=True) <pywebio.session.set_env>` to enable automatic scrolling. Note that when enabled, only "
#~ "outputting to ROOT scope can trigger automatic scrolling."
#~ msgstr ""
#~ "在进行一些持续性的输出时(比如日志输出)，有时希望在有新输出后自动将页面滚动到最下方，这时可以调用 `set_env(auto_scroll_bottom=True) <pywebio."
#~ "session.set_env>` 来开启自动滚动。\n"
#~ "注意，开启后，只有输出到ROOT Scope才可以触发自动滚动。"

#~ msgid "**Output Animation**"
#~ msgstr "**输出动画**"

#~ msgid ""
#~ "By default, PyWebIO will use the fade-in animation effect to display the content. You can use `set_env(output_animation=False) <pywebio.session."
#~ "set_env>` to turn off the animation."
#~ msgstr "PyWebIO在输出内容时默认会使用淡入的动画效果来显示内容，可使用 `set_env(output_animation=False) <pywebio.session.set_env>` 来关闭动画。"

#~ msgid "To view the effects of environment settings, please visit :demo_host:`set_env Demo </set_env_demo>`"
#~ msgstr "有关不同环境配置的效果可查看 :demo_host:`set_env Demo </set_env_demo>`"

#~ msgid "Server mode and Script mode"
#~ msgstr "Server模式与Script模式"

#~ msgid ""
#~ "Use `start_server() <pywebio.platform.tornado.start_server>` to start a web server and serve given PyWebIO applications on it. `start_server() "
#~ "<pywebio.platform.tornado.start_server>` accepts a function as PyWebIO application. In addition, `start_server() <pywebio.platform.tornado."
#~ "start_server>` also accepts a list of task function or a dictionary of it, so  one PyWebIO Server can have multiple services with different "
#~ "functions. You can use `go_app() <pywebio.session.go_app>` or `put_link() <pywebio.output.put_link>` to jump between services::"
#~ msgstr ""
#~ "使用 `start_server() <pywebio.platform.tornado.start_server>` 启动一个Web Server来将PyWebIO应用作为Web服务运行， `start_server() <pywebio."
#~ "platform.tornado.start_server>` 可以接收一个函数作为PyWebIO应用；\n"
#~ "也支持使用函数列表或字典，从而使一个PyWebIO Server下可以有多个不同功能的服务，服务之间可以通过 `go_app() <pywebio.session.go_app>` 或 "
#~ "`put_link() <pywebio.output.put_link>` 进行跳转::"

#~ msgid ""
#~ "def task_1():\n"
#~ "    put_text('task_1')\n"
#~ "    put_buttons(['Go task 2'], [lambda: go_app('task_2')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def task_2():\n"
#~ "    put_text('task_2')\n"
#~ "    put_buttons(['Go task 1'], [lambda: go_app('task_1')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def index():\n"
#~ "    put_link('Go task 1', app='task_1')  # Use `app` parameter to specify the task name\n"
#~ "    put_link('Go task 2', app='task_2')\n"
#~ "\n"
#~ "# equal to `start_server({'index': index, 'task_1': task_1, 'task_2': task_2})`\n"
#~ "start_server([index, task_1, task_2])"
#~ msgstr ""
#~ "def task_1():\n"
#~ "    put_text('task_1')\n"
#~ "    put_buttons(['Go task 2'], [lambda: go_app('task_2')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def task_2():\n"
#~ "    put_text('task_2')\n"
#~ "    put_buttons(['Go task 1'], [lambda: go_app('task_1')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def index():\n"
#~ "    put_link('Go task 1', app='task_1')  #  使用app参数指定任务名\n"
#~ "    put_link('Go task 2', app='task_2')\n"
#~ "\n"
#~ "# 等价于 start_server({'index': index, 'task_1': task_1, 'task_2': task_2})\n"
#~ "start_server([index, task_1, task_2])"

#~ msgid ""
#~ "Use `path_deploy() <pywebio.platform.path_deploy>` to deploy the PyWebIO applications from a directory. The python file under this directory "
#~ "need contain the ``main`` function to be seen as the PyWebIO application. You can access the application by using the file path as the URL."
#~ msgstr ""
#~ "使用 `path_deploy() <pywebio.platform.path_deploy>` 可以从一个路径中部署PyWebIO应用。位于该路径下的python文件需要包含名字为 ``main`` 的PyWebIO任"
#~ "务函数才能被视为PyWebIO应用程序。服务端会根据用户访问的URL来确定需要加载的文件并从中读取PyWebIO应用来运行。"

#~ msgid "For example, given the following folder structure::"
#~ msgstr "例如，给定如下文件结构::"

#~ msgid ""
#~ "If you use this directory in `path_deploy() <pywebio.platform.path_deploy>`, you can access the PyWebIO application in ``b.py`` by using URL "
#~ "``http://<host>:<port>/A/b``. And if the files have been modified after run `path_deploy() <pywebio.platform.path_deploy>`, you can use "
#~ "``reload`` URL parameter to reload application in the file: ``http://<host>:<port>/A/b?reload``"
#~ msgstr ""
#~ "如果使用以上路径调用 `path_deploy() <pywebio.platform.path_deploy>` ，你可以通过 URL ``http://<host>:<port>/A/b`` 来访问 ``b.py`` 文件中的PyWebIO"
#~ "应用。当文件在运行 `path_deploy() <pywebio.platform.path_deploy>` 之后被修改，可以使用 ``reload`` URL参数来重载文件: ``http://<host>:<port>/A/b?"
#~ "reload``"

#~ msgid ""
#~ "You can also use the command ``pywebio-path-deploy`` to start a server just like using `path_deploy() <pywebio.platform.path_deploy>`. For more "
#~ "information, refer ``pywebio-path-deploy --help``"
#~ msgstr ""
#~ "你还可以使用 ``pywebio-path-deploy`` 命令来启动一个和 `path_deploy() <pywebio.platform.path_deploy>` 效果一样的server。关于命令的更多信息请查阅命"
#~ "令帮助： ``pywebio-path-deploy --help``"

#~ msgid ""
#~ "In Server mode, you can use `pywebio.platform.seo()` to set the `SEO <https://en.wikipedia.org/wiki/Search_engine_optimization>`_ information. "
#~ "If ``seo()`` is not used, the `docstring <https://www.python.org/dev/peps/pep-0257/>`_ of the task function will be regarded as SEO information "
#~ "by default."
#~ msgstr ""
#~ "在Server模式下，可以使用 `pywebio.platform.seo()` 函数来设置任务函数SEO信息（在被搜索引擎索引时提供的网页信息，包含应用标题和应用简介），如果不使"
#~ "用 ``seo()`` 函数，默认条件下，PyWebIO会将任务函数的函数注释作为SEO信息（应用标题和简介之间使用一个空行分隔）。 "

#~ msgid "In Script mode, PyWebIO input and output functions can be called anywhere."
#~ msgstr "Script模式下，在任何位置都可以调用PyWebIO的交互函数。"

#~ msgid ""
#~ "The close of session may also be caused by the user closing the browser page. After the browser page is closed, PyWebIO input function calls "
#~ "that have not yet returned in the current session will cause `SessionClosedException <pywebio.exceptions.SessionClosedException>`, and "
#~ "subsequent calls to PyWebIO interactive functions will cause `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` or "
#~ "`SessionClosedException <pywebio.exceptions.SessionClosedException>`."
#~ msgstr ""
#~ "会话还会因为用户的关闭浏览器而结束，这时当前会话内还未返回的PyWebIO输入函数调用将抛出 `SessionClosedException <pywebio.exceptions."
#~ "SessionClosedException>` 异常，之后对于PyWebIO交互函数的调用将会产生 `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` 或 "
#~ "`SessionClosedException <pywebio.exceptions.SessionClosedException>` 异常。"

#~ msgid ""
#~ "You can use `defer_call(func) <pywebio.session.defer_call>` to set the function to be called when the session closes. Whether it is because the "
#~ "user closes the page or the task finishes to cause session closed, the function set by `defer_call(func) <pywebio.session.defer_call>` will be "
#~ "executed. `defer_call(func) <pywebio.session.defer_call>` can be used for resource cleaning. You can call `defer_call(func) <pywebio.session."
#~ "defer_call>` multiple times in the session, and the set functions will be executed sequentially after the session closes."
#~ msgstr ""
#~ "可以使用 `defer_call(func) <pywebio.session.defer_call>` 来设置会话结束时需要调用的函数。无论是因为用户主动关闭页面还是任务结束使得会话关闭，设置"
#~ "的函数都会被执行。\n"
#~ "`defer_call(func) <pywebio.session.defer_call>` 可以用于资源清理等工作。在会话中可以多次调用 `defer_call() <pywebio.session.defer_call>` ,会话结"
#~ "束后将会顺序执行设置的函数。"

#~ msgid "Integration with web framework"
#~ msgstr "与Web框架集成"

#~ msgid ""
#~ "The PyWebIO application can be integrated into an existing Python Web project, the PyWebIO application and the Web project share a web "
#~ "framework. PyWebIO currently supports integration with Flask, Tornado, Django, aiohttp and FastAPI(Starlette) web frameworks."
#~ msgstr ""
#~ "可以将PyWebIO应用集成到现有的Python Web项目中，PyWebIO应用与Web项目共用一个Web框架。目前支持与Flask、Tornado、Django、aiohttp和"
#~ "FastAPI(Starlette) Web框架的集成。"

#~ msgid "The integration methods of those web frameworks are as follows:"
#~ msgstr "不同Web框架的集成方法如下： "

#~ msgid ""
#~ "Use `pywebio.platform.tornado.webio_handler()` to get the `WebSocketHandler <https://www.tornadoweb.org/en/stable/websocket.html#tornado."
#~ "websocket.WebSocketHandler>`_ class for running PyWebIO applications in Tornado::"
#~ msgstr ""
#~ "使用 `pywebio.platform.tornado.webio_handler()` 来获取在Tornado中运行PyWebIO应用的 `WebSocketHandler <https://www.tornadoweb.org/en/stable/"
#~ "websocket.html#tornado.websocket.WebSocketHandler>`_ 类::"

#~ msgid ""
#~ "In above code, we add a routing rule to bind the ``WebSocketHandler`` of the PyWebIO application to the ``/tool`` path. After starting the "
#~ "Tornado server, you can visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "以上代码将 PyWebIO 应用的 ``WebSocketHandler`` 绑定到了 ``/tool`` 路径下。 启动Tornado后，访问 ``http://localhost/tool``即可打开PyWebIO应用。"

#~ msgid ""
#~ "PyWebIO uses the WebSocket protocol to communicate with the browser in Tornado. If your Tornado application is behind a reverse proxy (such as "
#~ "Nginx), you may need to configure the reverse proxy to support the WebSocket protocol. :ref:`Here <nginx_ws_config>` is an example of Nginx "
#~ "WebSocket configuration."
#~ msgstr ""
#~ "当使用Tornado后端时，PyWebIO使用WebSocket协议和浏览器进行通讯，如果你的Tornado应用处在反向代理(比如Nginx)之后，可能需要特别配置反向代理来支持"
#~ "WebSocket协议，:ref:`这里 <nginx_ws_config>` 有一个Nginx配置WebSocket的例子。"

#~ msgid "Use `pywebio.platform.flask.webio_view()` to get the view function for running PyWebIO applications in Flask::"
#~ msgstr "使用 `pywebio.platform.flask.webio_view()` 来获取在Flask中运行PyWebIO应用的视图函数::"

#~ msgid ""
#~ "In above code, we add a routing rule to bind the view function of the PyWebIO application to the ``/tool`` path. After starting the Flask "
#~ "application, visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "以上代码使用添加了一条路由规则将PyWebIO应用的视图函数绑定到 ``/tool`` 路径下。\n"
#~ "启动Flask应用后，访问 ``http://localhost/tool`` 即可打开PyWebIO应用"

#~ msgid "Use `pywebio.platform.django.webio_view()` to get the view function for running PyWebIO applications in Django::"
#~ msgstr "使用 `pywebio.platform.django.webio_view()` 来获取在Django中运行PyWebIO应用的视图函数::"

#~ msgid ""
#~ "In above code, we add a routing rule to bind the view function of the PyWebIO application to the ``/tool`` path. After starting the Django "
#~ "server, visit ``http://localhost/tool`` to open the PyWebIO application"
#~ msgstr ""
#~ "以上代码使用添加了一条路由规则将PyWebIO应用的视图函数绑定到 ``/tool`` 路径下。\n"
#~ "启动Django应用后，访问 ``http://localhost/tool`` 即可打开PyWebIO应用"

#~ msgid ""
#~ "Use `pywebio.platform.aiohttp.webio_handler()` to get the `Request Handler <https://docs.aiohttp.org/en/stable/web_quickstart.html#aiohttp-web-"
#~ "handler>`_ coroutine for running PyWebIO applications in aiohttp::"
#~ msgstr ""
#~ "使用 `pywebio.platform.aiohttp.webio_handler()` 来获取在aiohttp中运行PyWebIO应用的 `Request Handler <https://docs.aiohttp.org/en/stable/"
#~ "web_quickstart.html#aiohttp-web-handler>`_ 协程::"

#~ msgid "After starting the aiohttp server, visit ``http://localhost/tool`` to open the PyWebIO application"
#~ msgstr "启动aiohttp应用后，访问 ``http://localhost/tool`` 即可打开PyWebIO应用"

#~ msgid ""
#~ "PyWebIO uses the WebSocket protocol to communicate with the browser in aiohttp. If your aiohttp server is behind a reverse proxy (such as "
#~ "Nginx), you may need to configure the reverse proxy to support the WebSocket protocol. :ref:`Here <nginx_ws_config>` is an example of Nginx "
#~ "WebSocket configuration."
#~ msgstr ""
#~ "当使用aiohttp后端时，PyWebIO使用WebSocket协议和浏览器进行通讯，如果你的aiohttp应用处在反向代理(比如Nginx)之后，\n"
#~ "可能需要特别配置反向代理来支持WebSocket协议，:ref:`这里 <nginx_ws_config>` 有一个Nginx配置WebSocket的例子。"

#~ msgid ""
#~ "Use `pywebio.platform.fastapi.webio_routes()` to get the FastAPI/Starlette routes for running PyWebIO applications. You can mount the routes to "
#~ "your FastAPI/Starlette app."
#~ msgstr ""
#~ "使用 `pywebio.platform.fastapi.webio_routes()` 来获取在FastAPI/Starlette中运行PyWebIO应用的路由组件，你可以将其挂载在到FastAPI/Starlette应用中。"

#~ msgid "After starting the server by using ``uvicorn <module>:app`` , visit ``http://localhost:8000/tool/`` to open the PyWebIO application"
#~ msgstr "使用 ``uvicorn <module>:app` 启动server后，访问 ``http://localhost:8000/tool/`` 即可打开PyWebIO应用"

#~ msgid ""
#~ "PyWebIO uses the WebSocket protocol to communicate with the browser in FastAPI/Starlette. If your server is behind a reverse proxy (such as "
#~ "Nginx), you may need to configure the reverse proxy to support the WebSocket protocol. :ref:`Here <nginx_ws_config>` is an example of Nginx "
#~ "WebSocket configuration."
#~ msgstr ""
#~ "当使用FastAPI或Starlette后端时，PyWebIO使用WebSocket协议和浏览器进行通讯，如果你的aiohttp应用处在反向代理(比如Nginx)之后，\n"
#~ "可能需要特别配置反向代理来支持WebSocket协议，:ref:`这里 <nginx_ws_config>` 有一个Nginx配置WebSocket的例子。"

#~ msgid "**Deployment in production**"
#~ msgstr "**生产环境部署**"

#~ msgid ""
#~ "In your production system, you may want to deploy the web applications with some WSGI/ASGI servers such as uWSGI, Gunicorn, and Uvicorn. Since "
#~ "PyWebIO applications store session state in memory of process, when you use HTTP-based sessions (Flask and Django) and spawn multiple workers to "
#~ "handle requests, the request may be dispatched to a process that does not hold the session to which the request belongs. So you can only start "
#~ "one worker to handle requests when using Flask or Django backend."
#~ msgstr ""
#~ "在生产环境中，你可能会使用一些 WSGI/ASGI 服务器（如 uWSGI、Gunicorn、Uvicorn）部署 Web 应用程序。由于 PyWebIO 应用程序会在进程中存储会话状态，当"
#~ "使用基于 HTTP 的会话（使用Flask 和 Django后端时）并生成多个进程来处理请求时，请求可能会被分发到错误的进程中。因此，在使用基于 HTTP 的会话时，只能"
#~ "启动一个进程来处理请求。"

#~ msgid ""
#~ "If you still want to use multiple processes to increase concurrency, one way is to use Uvicorn+FastAPI, or you can also start multiple Tornado/"
#~ "aiohttp processes and add external load balancer (such as HAProxy or nginx) before them. Those backends use the WebSocket protocol to "
#~ "communicate with the browser in PyWebIO, so there is no the issue as described above."
#~ msgstr ""
#~ "如果仍然希望使用多进程来提高并发，一种方式是使用 Uvicorn+FastAPI，或者你也可以启动多个Tornado/aiohttp进程，并在它们之前添加外部的负载均衡软件"
#~ "（如 HAProxy 或 nginx）。这些后端使用 WebSocket 协议与浏览器进行通信，所以不存在上述问题。"

#~ msgid "**Static resources Hosting**"
#~ msgstr "**PyWebIO静态资源的托管**"

#~ msgid ""
#~ "By default, the front-end of PyWebIO gets required static resources from CDN. If you want to deploy PyWebIO applications in an offline "
#~ "environment, you need to host static files by yourself, and set the ``cdn`` parameter of ``webio_view()`` or ``webio_handler()`` to ``False``."
#~ msgstr ""
#~ "PyWebIO默认使用CDN来获取前端的静态资源，如果要将PyWebIO应用部署到离线环境中，需要自行托管静态文件，\n"
#~ "并将 ``webio_view()`` 或 ``webio_handler()`` 的 ``cdn`` 参数设置为 ``False`` 。"

#~ msgid ""
#~ "When setting ``cdn=False`` , you need to host the static resources in the same directory as the PyWebIO application. In addition, you can also "
#~ "pass a string to ``cdn`` parameter to directly set the URL of PyWebIO static resources directory."
#~ msgstr ""
#~ "``cdn=False``  时需要将静态资源托管在和PyWebIO应用同级的目录下。\n"
#~ "同时，也可以通过 ``cdn`` 参数直接设置PyWebIO静态资源的URL目录。"

#~ msgid ""
#~ "The path of the static file of PyWebIO is stored in ``pywebio.STATIC_PATH``, you can use the command ``python3 -c \"import pywebio; "
#~ "print(pywebio.STATIC_PATH)\"`` to print it out."
#~ msgstr ""
#~ "PyWebIO的静态文件的路径保存在 ``pywebio.STATIC_PATH`` 中，可使用命令 ``python3 -c \"import pywebio; print(pywebio.STATIC_PATH)\"`` 将其打印出来。"

#~ msgid ""
#~ "``start_server()`` and ``path_deploy()`` also support ``cdn`` parameter, if it is set to ``False``, the static resource will be hosted in local "
#~ "server automatically, without manual hosting."
#~ msgstr "使用 ``start_server()`` 启动的应用，如果将 ``cdn`` 参数设置为 ``False`` ，会自动启动一个本地的静态资源托管服务，无需手动托管。"

#~ msgid "Coroutine-based session"
#~ msgstr "基于协程的会话"

#~ msgid ""
#~ "This section will introduce the advanced features of PyWebIO --- coroutine-based session. In most cases, you don’t need it. All functions or "
#~ "methods in PyWebIO that are only used for coroutine sessions are specifically noted in the document."
#~ msgstr "关于协程内容属于高级特性，您不必使用此部分也可以实现PyWebIO支持的全部功能。PyWebIO中所有仅用于协程会话的函数或方法都在文档中有特别说明。"

#~ msgid ""
#~ "PyWebIO's session is based on thread by default. Each time a user opens a session connection to the server, PyWebIO will start a thread to run "
#~ "the task function. In addition to thread-based sessions, PyWebIO also provides coroutine-based sessions. Coroutine-based sessions accept "
#~ "coroutine functions as task functions."
#~ msgstr ""
#~ "PyWebIO的会话实现默认是基于线程的，用户每打开一个和服务端的会话连接，PyWebIO会启动一个线程来运行任务函数。\n"
#~ "除了基于线程的会话，PyWebIO还提供了基于协程的会话。基于协程的会话接受协程函数作为任务函数。"

#~ msgid ""
#~ "The session based on the coroutine is a single-thread model, which means that all sessions run in a single thread. For IO-bound tasks, "
#~ "coroutines take up fewer resources than threads and have performance comparable to threads. In addition, the context switching of the coroutine "
#~ "is predictable, which can reduce the need for program synchronization and locking, and can effectively avoid most critical section problems."
#~ msgstr ""
#~ "基于协程的会话为单线程模型，所有会话都运行在一个线程内。对于IO密集型的任务，协程比线程占用更少的资源同时又拥有媲美于线程的性能。\n"
#~ "另外，协程的上下文切换具有可预测性，能够减少程序同步与加锁的需要，可以有效避免大多数临界区问题。"

#~ msgid "Using coroutine session"
#~ msgstr "使用协程会话"

#~ msgid ""
#~ "To use coroutine-based session, you need to use the ``async`` keyword to declare the task function as a coroutine function, and use the "
#~ "``await`` syntax to call the PyWebIO input function:"
#~ msgstr "要使用基于协程的会话，需要使用 ``async`` 关键字将任务函数声明为协程函数，并使用 ``await`` 语法调用PyWebIO输入函数:"

#~ msgid ""
#~ "In the coroutine task function, you can also use ``await`` to call other coroutines or ( `awaitable objects <https://docs.python.org/3/library/"
#~ "asyncio-task.html#asyncio-awaitables>`_ ) in the standard library `asyncio <https://docs.python.org/3/library/asyncio.html>`_:"
#~ msgstr ""
#~ "在协程任务函数中，也可以使用 ``await`` 调用其他协程或标准库 `asyncio <https://docs.python.org/3/library/asyncio.html>`_ 中的可等待对象"
#~ "( `awaitable objects <https://docs.python.org/3/library/asyncio-task.html#asyncio-awaitables>`_ ):"

#~ msgid ""
#~ "In coroutine-based session, all input functions defined in the :doc:`pywebio.input </input>` module need to use ``await`` syntax to get the "
#~ "return value. Forgetting to use ``await`` will be a common error when using coroutine-based session."
#~ msgstr ""
#~ "在基于协程的会话中， :doc:`pywebio.input </input>` 模块中的定义输入函数都需要使用 ``await`` 语法来获取返回值，忘记使用 ``await`` 将会是在使用基于"
#~ "协程的会话时常出现的错误。"

#~ msgid "Other functions that need to use ``await`` syntax in the coroutine session are:"
#~ msgstr "其他在协程会话中也需要使用 ``await`` 语法来进行调用函数有:"

#~ msgid ""
#~ "Although the PyWebIO coroutine session is compatible with the ``awaitable objects`` in the standard library ``asyncio``, the ``asyncio`` library "
#~ "is not compatible with the ``awaitable objects`` in the PyWebIO coroutine session."
#~ msgstr ""
#~ "虽然PyWebIO的协程会话兼容标准库 ``asyncio`` 中的 ``awaitable objects`` ，但 ``asyncio`` 库不兼容PyWebIO协程会话中的 ``awaitable objects`` ."

#~ msgid ""
#~ "That is to say, you can't pass PyWebIO ``awaitable objects`` to the ``asyncio`` functions that accept ``awaitable objects``. For example, the "
#~ "following calls are **not supported** ::"
#~ msgstr ""
#~ "也就是说，无法将PyWebIO中的 ``awaitable objects`` 传入 ``asyncio`` 中的接受 ``awaitable objects`` 作为参数的函数中，比如如下调用是 **不被支持的"
#~ "** ::"

#~ msgid "Concurrency in coroutine-based sessions"
#~ msgstr "协程会话的并发"

#~ msgid ""
#~ "In coroutine-based session, you can start new thread, but you cannot call PyWebIO interactive functions in it (`register_thread() <pywebio."
#~ "session.register_thread>` is not available in coroutine session). But you can use `run_async(coro) <pywebio.session.run_async>` to execute a "
#~ "coroutine object asynchronously, and PyWebIO interactive functions can be used in the new coroutine:"
#~ msgstr ""
#~ "在基于协程的会话中，你可以启动线程，但是无法在其中调用PyWebIO交互函数（ `register_thread() <pywebio.session.register_thread>` 在协程会话中不可"
#~ "用）。\n"
#~ "但你可以使用 `run_async(coro) <pywebio.session.run_async>` 来异步执行一个协程对象，新协程内可以使用PyWebIO交互函数:"

#~ msgid ""
#~ "`run_async(coro) <pywebio.session.run_async>` returns a `TaskHandler <pywebio.session.coroutinebased.TaskHandler>`, which can be used to query "
#~ "the running status of the coroutine or close the coroutine."
#~ msgstr ""
#~ "`run_async(coro) <pywebio.session.run_async>` 返回一个 `TaskHandler <pywebio.session.coroutinebased.TaskHandler>` ，通过该 `TaskHandler <pywebio."
#~ "session.coroutinebased.TaskHandler>` 可以查询协程运行状态和关闭协程。"

#~ msgid ""
#~ "Similar to thread-based session, in coroutine-based session, when the task function and the coroutine running through `run_async() <pywebio."
#~ "session.run_async>` in the session are all finished, the session is closed."
#~ msgstr ""
#~ "与基于线程的会话类似，在基于协程的会话中，当任务函数和在会话内通过 `run_async() <pywebio.session.run_async>` 运行的协程全部结束后，会话关闭。"

#~ msgid ""
#~ "If the close of the session is caused by the user closing the browser, the behavior of PyWebIO is the same as :ref:`Thread-based session "
#~ "<session_close>`: After the browser page closed, PyWebIO input function calls that have not yet returned in the current session will cause "
#~ "`SessionClosedException <pywebio.exceptions.SessionClosedException>`, and subsequent calls to PyWebIO interactive functions will cause "
#~ "`SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` or `SessionClosedException <pywebio.exceptions.SessionClosedException>`."
#~ msgstr ""
#~ "对于因为用户的关闭浏览器而造成的会话结束，处理逻辑和 :ref:`基于线程的会话 <session_close>` 一致:\n"
#~ "此时当前会话内还未返回的PyWebIO输入函数调用将抛出 `SessionClosedException <pywebio.exceptions.SessionClosedException>` 异常，之后对于PyWebIO交互"
#~ "函数的调用将会产生 `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` 或 `SessionClosedException <pywebio.exceptions."
#~ "SessionClosedException>` 异常。"

#~ msgid "`defer_call(func) <pywebio.session.defer_call>` also available in coroutine session."
#~ msgstr "协程会话也同样支持使用 `defer_call(func) <pywebio.session.defer_call>` 来设置会话结束时需要调用的函数。"

#~ msgid "Integration with Web Framework"
#~ msgstr "协程会话与Web框架集成"

#~ msgid "The PyWebIO application that using coroutine-based session can also be integrated to the web framework."
#~ msgstr "基于协程的会话同样可以与Web框架进行集成，只需要在原来传入任务函数的地方改为传入协程函数即可。"

#~ msgid "However, there are some limitations when using coroutine-based sessions to integrate into Flask or Django:"
#~ msgstr "但当前在使用基于协程的会话集成进Flask或Django时，存在一些限制："

#~ msgid ""
#~ "First, when ``await`` the coroutine objects/awaitable objects in the ``asyncio`` module, you need to use `run_asyncio_coroutine() <pywebio."
#~ "session.run_asyncio_coroutine>` to wrap the coroutine object."
#~ msgstr ""
#~ "一是协程函数内还无法直接通过 ``await`` 直接等待asyncio库中的协程对象，目前需要使用 `run_asyncio_coroutine() <pywebio.session."
#~ "run_asyncio_coroutine>` 进行包装。"

#~ msgid "Secondly, you need to start a new thread to run the event loop before starting a Flask/Django server."
#~ msgstr "二是，在启动Flask/Django这类基于线程的服务器之前需要启动一个单独的线程来运行事件循环。"

#~ msgid "Example of coroutine-based session integration into Flask:"
#~ msgstr "使用基于协程的会话集成进Flask的示例:"

#~ msgid ""
#~ "Finally, coroutine-based session is not available in the script mode. You always need to use ``start_server()`` to run coroutine task function "
#~ "or integrate it to a web framework."
#~ msgstr "最后，使用PyWebIO编写的协程函数不支持Script模式，总是需要使用 ``start_server`` 来启动一个服务或者集成进Web框架来调用。"

#~ msgid ""
#~ "You can use ``code`` parameter in :func:`pywebio.input.textarea()` to make a code editing textarea. This feature uses `Codemirror <https://"
#~ "codemirror.net/>`_ as underlying implementation. The ``code`` parameter accept the Codemirror options as a dict."
#~ msgstr ""
#~ ":func:`pywebio.input.textarea` 还支持使用 `Codemirror <https://codemirror.net/>`_ 实现代码风格的编辑区，只需使用 ``code`` 参数传入Codemirror支持"
#~ "的选项即可(最简单的情况是直接传入 ``code={}`` 或 ``code=True``):"

#~ msgid ""
#~ ":ref:`Here <codemirror_options>` are some commonly used Codemirror options. For complete Codemirror options, please visit: https://codemirror."
#~ "net/doc/manual.html#config"
#~ msgstr ":ref:`这里 <codemirror_options>` 列举了一些常用的Codemirror选项，完整的Codemirror选项请见：https://codemirror.net/doc/manual.html#config"

#~ msgid ""
#~ "Scopes can be nested. At the beginning, PyWebIO applications have only one ``ROOT`` Scope. Each time a new scope is created, the nesting level "
#~ "of the scope will increase by one level, and each time the current scope is exited, the nesting level of the scope will be reduced by one. "
#~ "PyWebIO uses the Scope stack to save the scope nesting level at runtime."
#~ msgstr ""
#~ "Scope是可嵌套的，初始条件下，PyWebIO应用只有一个最顶层的 ``ROOT`` Scope。每创建一个新Scope，Scope的嵌套层级便会多加一层，每退出当前Scope，Scope的"
#~ "嵌套层级便会减少一层。PyWebIO使用Scope栈来保存运行时的Scope的嵌套层级。"

#~ msgid "For example, the following code will create 3 scopes:"
#~ msgstr "例如，如下代码将会创建3个Scope:"

#~ msgid ""
#~ "Another way to deploy PyWebIO application as web service is using `path_deploy() <pywebio.platform.path_deploy>`. `path_deploy() <pywebio."
#~ "platform.path_deploy>` is used to deploy the PyWebIO applications from a directory. Each python file under this directory defines a PyWebIO "
#~ "application. You can access the application by using the file path as the URL. Refer to :ref:`platform module <dir_deploy>` for more information."
#~ msgstr ""
#~ "将PyWebIO应用部署为web服务的另一种方式是使用 `path_deploy() <pywebio.platform.path_deploy>` 。`path_deploy() <pywebio.platform.path_deploy>` 可以"
#~ "从一个目录中部署PyWebIO应用，只需要在该目录下的python文件中定义PyWebIO应用，就可以通过URL中的路径来访问这些应用了。"

#~ msgid "PyWebIO provides a series of functions to output text, tables, images, etc:"
#~ msgstr "PyWebIO提供了一系列函数来输出文本、表格、图像等格式:"

#~ msgid "**Placeholder**"
#~ msgstr "**占位符**"

#~ msgid ""
#~ "When using combination output, if you want to dynamically update the ``put_xxx()`` content after it has been output, you can use the `output() "
#~ "<pywebio.output.output>` function. `output() <pywebio.output.output>` is like a placeholder, it can be passed in anywhere that ``put_xxx()`` can "
#~ "passed in. And after being output, the content can also be modified:"
#~ msgstr ""
#~ "使用组合输出时，如果想在内容输出后，对其中的 ``put_xxx()`` 子项进行动态修改，可以使用 `output() <pywebio.output.output>` 函数，\n"
#~ "`output() <pywebio.output.output>` 就像一个占位符，它可以像 ``put_xxx()`` 一样传入 `put_table` 、 `popup` 、 `put_widget` 等函数中作为输出的一部"
#~ "分，\n"
#~ "并且，在输出后，还可以对其中的内容进行修改(比如重置或增加内容):"

#~ msgid "`set_scope(name) <pywebio.output.set_scope>` : Create scope at current location(or specified location)"
#~ msgstr "`set_scope(name) <pywebio.output.set_scope>` : 在当前位置（或指定位置）创建scope"
